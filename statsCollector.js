// Tamper Monkey Script
// ==UserScript==
// @name         CSV Data Collector
// @namespace    http://tampermonkey.net/
// @version      0.1.0
// @description  Finds a CSV download link, parses the file, and displays it in a floating popup.
// @author       Viet Cat (Generated by Gemini)
// @match        https://footystats.org/
// @grant        GM_xmlhttpRequest
// @grant        GM.xmlHttpRequest
// @icon         https://www.google.com/s2/favicons?sz=64&domain=footystats.org
// @connect      *
// ==/UserScript==

/**
 * Main script function - wrapped in IIFE for scope isolation
 * This script creates a floating popup to collect and display data from a CSV file.
 * Features:
 * - Finds a CSV download link on the page (needs configuration).
 * - Fetches and parses the CSV data.
 * - Displays data in a dynamic table.
 * - Auto-refresh with configurable intervals.
 * - Manual refresh, pause/resume functionality.
 * - Draggable, resizable, and collapsible UI.
 */
;(function () {
  'use strict'

  try {
    console.log('CSV Collector: Script starting...')

    // ==================== CONSTANTS ====================
    const CONSTANTS = {
      REFRESH: {
        DEFAULT_INTERVAL: 10,
        NO_DATA_INTERVAL: 5,
        DATA_FOUND_INTERVAL: 60,
      },
      POPUP: {
        DEFAULT_WIDTH: 450,
        MIN_WIDTH: 300,
        MIN_HEIGHT: 200,
        HEADER_HEIGHT: 40,
      },
      COLORS: {
        HEADER_GRADIENT_START: '#005f73',
        HEADER_GRADIENT_END: '#0a9396',
        BACKGROUND: '#f8f9fa',
        BORDER: '#dee2e6',
        HEADER_BACKGROUND: '#e9ecef',
      },
      ANIMATIONS: {
        SPIN_DURATION: 1000,
      },
    }

    // ==================== SETTINGS (USER CONFIG) ====================
    const SETTINGS_STORAGE_KEY = 'csv_collector_settings_v1'
    const settings = loadSettings()

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_STORAGE_KEY)
        const parsed = raw ? JSON.parse(raw) : {}
        return {
          defaultInterval:
            Number(parsed.defaultInterval) > 0
              ? Number(parsed.defaultInterval)
              : CONSTANTS.REFRESH.DEFAULT_INTERVAL,
          noDataInterval:
            Number(parsed.noDataInterval) > 0
              ? Number(parsed.noDataInterval)
              : CONSTANTS.REFRESH.NO_DATA_INTERVAL,
          dataFoundInterval:
            Number(parsed.dataFoundInterval) > 0
              ? Number(parsed.dataFoundInterval)
              : CONSTANTS.REFRESH.DATA_FOUND_INTERVAL,
          requestDelay:
            Number(parsed.requestDelay) >= 0
              ? Number(parsed.requestDelay)
              : 3000, // Default 3000ms
        }
      } catch (_) {
        return {
          defaultInterval: CONSTANTS.REFRESH.DEFAULT_INTERVAL,
          noDataInterval: CONSTANTS.REFRESH.NO_DATA_INTERVAL,
          dataFoundInterval: CONSTANTS.REFRESH.DATA_FOUND_INTERVAL,
          requestDelay: 3000,
        }
      }
    }

    function saveSettings(newSettings) {
      try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(newSettings))
      } catch (_) {}
    }

    // ==================== STATE MANAGEMENT ====================
    const state = {
      timeLeft: CONSTANTS.REFRESH.DEFAULT_INTERVAL,
      refreshIntervalId: null,
      isPaused: false,
      isRefreshing: false,
      currentInterval: CONSTANTS.REFRESH.DEFAULT_INTERVAL,
      isDragging: false,
      isResizing: false,
      isCollapsed: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startTop: 0,
      startWidth: 0,
      startHeight: 0,
      originalWidth: CONSTANTS.POPUP.DEFAULT_WIDTH,
      originalHeight: 0,
      lastRequestStartTime: 0, // Timestamp of the last background request start
      lastDataSignature: '',
      isProcessingUrls: false, // To specifically track this background task
      cancelProcessing: false, // Flag to signal cancellation
      extraHeaders: [], // Stores the keys of extra columns in order
    }

    // ==================== UTILITY FUNCTIONS ====================
    /**
     * Creates a delay for a specified number of milliseconds.
     * @param {number} ms - The number of milliseconds to wait.
     * @returns {Promise<void>}
     */
    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms))
    }

    // ==================== CSV PROCESSING ====================

    /**
     * Finds the CSV download link on the page.
     * NOTE: You MUST configure the selector to match the target website.
     * @returns {string|null} The URL of the CSV file or null if not found.
     */
    function findCsvDownloadLink() {
      // ================== USER CONFIGURATION ==================
      // XPath để tìm thẻ a có chứa link download.
      const xpath =
        "//div[@id = 'content']/div/div/div/div/a[./i[contains(@class,'download')]]"
      // ========================================================

      try {
        const result = document.evaluate(
          xpath,
          document,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        )
        const linkElement = result.singleNodeValue

        if (linkElement && linkElement.href) {
          // Đảm bảo link là một URL tuyệt đối (absolute)
          return new URL(linkElement.href, window.location.href).href
        }
      } catch (error) {
        console.error(
          'CSV Collector: Lỗi khi thực thi XPath để tìm link download:',
          error
        )
      }
      return null
    }

    /**
     * Fetches a CSV file and parses it into an array of arrays.
     * @param {string} url - The URL of the CSV file.
     * @returns {Promise<Array<Array<string>>>} A promise that resolves to the parsed data.
     */
    function fetchAndParseCsv(url) {
      return new Promise((resolve, reject) => {
        window.logToPopup(`Fetching CSV from ${url}...`)
        // Use GM_xmlhttpRequest for cross-origin requests
        GM_xmlhttpRequest({
          method: 'GET',
          url: url,
          onload: function (response) {
            if (response.status >= 200 && response.status < 300) {
              window.logToPopup('CSV file fetched successfully. Parsing...')
              const parsedData = parseCsvText(response.responseText)
              resolve(parsedData)
            } else {
              reject(
                new Error(`Failed to fetch CSV: Status ${response.status}`)
              )
            }
          },
          onerror: function (error) {
            reject(new Error(`Network error fetching CSV: ${error.details}`))
          },
        })
      })
    }

    /**
     * Parses a string of CSV text into an array of arrays.
     * Handles quoted fields containing commas.
     * @param {string} csvText - The raw CSV text.
     * @returns {Array<Array<string>>} The parsed data.
     */
    function parseCsvText(csvText) {
      const rows = []
      if (!csvText) return rows

      const lines = csvText.trim().split('\n')
      for (const line of lines) {
        const row = []
        let currentField = ''
        let inQuotes = false
        for (let i = 0; i < line.length; i++) {
          const char = line[i]
          if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
            // Handles standard quotes, ignores escaped quotes
            inQuotes = !inQuotes
          } else if (char === ',' && !inQuotes) {
            row.push(currentField.trim())
            currentField = ''
          } else {
            currentField += char
          }
        }
        row.push(currentField.trim())
        rows.push(row)
      }
      return rows
    }

    // ==================== UI & TABLE FUNCTIONS ====================

    /**
     * Creates a table cell with consistent styling.
     * @param {string} content - Cell content.
     * @returns {HTMLElement} - Styled table cell.
     */
    function createTableCell(content) {
      const td = document.createElement('td')
      td.textContent = content
      td.style.cssText = `
        border: 1px solid ${CONSTANTS.COLORS.BORDER};
        padding: 6px 8px;
        text-align: left;
        white-space: nowrap;
      `
      return td
    }

    /**
     * Updates the popup table with parsed CSV data.
     * @param {Array<Array<string>>} data - Array of rows, where each row is an array of strings.
     * @param {HTMLElement} tbody - Table body element to update.
     */
    function updateTableWithData(data, tbody) {
      try {
        const signature = JSON.stringify(data)
        if (signature === state.lastDataSignature) {
          window.logToPopup('Data unchanged, skipping table update.')
          return
        }
        state.lastDataSignature = signature

        const table = tbody.closest('table')
        if (!table) return

        const thead = table.querySelector('thead')
        tbody.innerHTML = ''
        thead.innerHTML = ''

        if (!data || data.length === 0) {
          // Cập nhật colspan để khớp với số cột sẽ hiển thị (9 cột)
          tbody.innerHTML = '<tr><td colspan="9">No data to display.</td></tr>'
          return
        }

        // ================== USER CONFIGURATION ==================
        // Chỉ định các cột (theo index, bắt đầu từ 0) muốn hiển thị.
        // Tương ứng với cột 2,3,4,5,6,46,47,48,107 trong file CSV (do index bắt đầu từ 0).
        const columnsToShow = [1, 2, 3, 4, 5, 45, 46, 47, 106]
        // ========================================================

        // Create header row
        const headerRow = document.createElement('tr')
        const headers = data[0]
        columnsToShow.forEach((colIndex) => {
          // Lấy header, nếu không tồn tại thì dùng tên mặc định
          const headerText = headers[colIndex] ?? `Cột ${colIndex + 1}`
          const th = document.createElement('th')
          th.textContent = headerText
          th.style.cssText = `
            border: 1px solid ${CONSTANTS.COLORS.BORDER};
            padding: 8px;
            background-color: ${CONSTANTS.COLORS.HEADER_BACKGROUND};
            font-weight: bold;
            text-align: left;
            position: sticky;
            top: 0;
          `
          headerRow.appendChild(th)
        })
        thead.appendChild(headerRow)

        // Create data rows
        const dataRows = data.slice(1)
        dataRows.forEach((rowData) => {
          const tr = document.createElement('tr')
          columnsToShow.forEach((colIndex) => {
            // Dùng ?? '' để đảm bảo an toàn nếu dữ liệu cột không tồn tại
            const cellData = rowData[colIndex] ?? ''
            tr.appendChild(createTableCell(cellData))
          })
          tbody.appendChild(tr)
        })

        window.logToPopup(`Table updated with ${dataRows.length} rows.`)
        adjustPopupWidth()

        // Bắt đầu xử lý các dòng trong bảng, tạm dừng refresh trong khi thực hiện
        setTimeout(
          () => withRefreshSuspended(() => processTableRowsForUrls(tbody)),
          500
        )
      } catch (error) {
        console.error('CSV Collector: Error in updateTableWithData:', error)
        window.logToPopup(`Error updating table: ${error.message}`)
      }
    }

    /**
     * Adjusts popup width based on table content.
     */
    function adjustPopupWidth() {
      const table = document.querySelector('#csv-collector-popup table')
      if (!table) return

      const popup = document.getElementById('csv-collector-popup')
      if (popup) {
        const requiredWidth = table.scrollWidth + 40 // Add padding
        const newWidth = Math.min(
          Math.max(requiredWidth, CONSTANTS.POPUP.MIN_WIDTH),
          window.innerWidth - 40
        )
        popup.style.width = `${newWidth}px`
        state.originalWidth = newWidth
      }
    }

    /**
     * Tuần tự duyệt qua các dòng của bảng, tìm URL và xử lý chúng trong tab mới.
     * @param {HTMLElement} tbody - Phần thân của bảng chứa các dòng dữ liệu.
     */
    async function processTableRowsForUrls(tbody) {
      window.logToPopup('Starting to process rows for additional data...')
      const rows = tbody.querySelectorAll('tr')
      window.logToPopup(`Found ${rows.length} rows to process.`)
      for (const row of rows) {
        // Check for cancellation signal at the start of each iteration
        if (state.cancelProcessing) {
          window.logToPopup('URL processing was cancelled by the user.')
          // Reset the 'loading' status for any rows that were in progress
          tbody
            .querySelectorAll("tr[data-processed='loading']")
            .forEach((r) => {
              r.dataset.processed = '' // Allow reprocessing next time
              const statusCell = r.querySelector('.status-cell')
              if (statusCell) statusCell.remove()
            })
          break // Exit the loop
        }

        // Bỏ qua nếu dòng đã được xử lý hoặc đang được xử lý
        if (row.dataset.processed) continue

        // Đánh dấu là đang xử lý để tránh lặp lại
        row.dataset.processed = 'loading'

        const lastCell = row.cells[row.cells.length - 1]
        if (!lastCell) continue

        const url = lastCell.textContent.trim()

        // Kiểm tra xem nội dung có phải là một URL tuyệt đối hoặc một đường dẫn tương đối (bắt đầu bằng /)
        if (
          url.startsWith('http://') ||
          url.startsWith('https://') ||
          url.startsWith('/')
        ) {
          try {
            // --- DYNAMIC DELAY LOGIC ---
            // Chờ cho đến khi đủ thời gian delay cấu hình kể từ lần request cuối cùng.
            // Logic này thay thế cho việc delay cứng.
            const requiredDelay = settings.requestDelay || 3000
            while (Date.now() - state.lastRequestStartTime < requiredDelay) {
              window.logToPopup(
                `Waiting for ${
                  requiredDelay / 1000
                }s gap before next request...`
              )
              await delay(1000) // Chờ 1 giây rồi kiểm tra lại
            }
            // Đánh dấu thời điểm bắt đầu request mới
            state.lastRequestStartTime = Date.now()

            window.logToPopup(`Processing URL: ${url}`)
            updateTableRowWithExtraData(row, { status: 'loading' })

            // Thay thế việc mở tab mới bằng cách fetch dữ liệu trong nền
            const extraData = await processUrlInBackground(url)
            updateTableRowWithExtraData(row, {
              status: 'success',
              data: extraData,
            })
            window.logToPopup(`Successfully fetched data for ${url}`)
          } catch (error) {
            updateTableRowWithExtraData(row, {
              status: 'error',
              message: error.message,
            })
            window.logToPopup(
              `Failed to fetch data for ${url}: ${error.message}`
            )
          }
        } else {
          // Nếu không phải URL, đánh dấu là đã hoàn thành
          row.dataset.processed = 'done'
        }
      }
      if (!state.cancelProcessing) {
        window.logToPopup('Finished processing all rows.')
      }
    }

    /**
     * Fetches a URL in the background, parses its HTML, and extracts data.
     * @param {string} url - The URL to process (can be relative or absolute).
     * @returns {Promise<object>} - Một promise giải quyết với dữ liệu được trích xuất.
     */
    function processUrlInBackground(url) {
      return new Promise((resolve, reject) => {
        // Đảm bảo URL là tuyệt đối để GM_xmlhttpRequest hoạt động chính xác
        const absoluteUrl = new URL(url, window.location.href).href

        GM_xmlhttpRequest({
          method: 'GET',
          url: absoluteUrl,
          onload: function (response) {
            if (response.status >= 200 && response.status < 300) {
              try {
                const parser = new DOMParser()
                const doc = parser.parseFromString(
                  response.responseText,
                  'text/html'
                )
                const extraData = extractDataFromChildPage(doc)
                resolve(extraData)
              } catch (e) {
                reject(
                  new Error(
                    `Failed to parse HTML for ${absoluteUrl}: ${e.message}`
                  )
                )
              }
            } else {
              reject(
                new Error(
                  `Failed to fetch ${absoluteUrl}: Status ${response.status}`
                )
              )
            }
          },
          onerror: function (error) {
            reject(
              new Error(
                `Network error fetching ${absoluteUrl}: ${error.details}`
              )
            )
          },
        })
      })
    }

    /**
     * Cập nhật một dòng trong bảng với dữ liệu bổ sung hoặc trạng thái.
     * @param {HTMLElement} row - Phần tử <tr> cần cập nhật.
     * @param {object} result - Kết quả xử lý, chứa trạng thái và dữ liệu.
     */
    function updateTableRowWithExtraData(row, result) {
      const table = row.closest('table')
      if (!table) return
      const thead = table.querySelector('thead')
      const headerRow = thead.querySelector('tr')

      // Xóa các ô trạng thái và dữ liệu bổ sung cũ để vẽ lại cho đúng thứ tự
      row
        .querySelectorAll('.status-cell, .extra-cell')
        .forEach((c) => c.remove())

      if (result.status === 'loading') {
        const cell = createTableCell('Loading...')
        cell.classList.add('status-cell')
        row.appendChild(cell)
      } else if (result.status === 'error') {
        const cell = createTableCell(`Error: ${result.message}`)
        cell.style.color = 'red'
        cell.classList.add('status-cell')
        row.appendChild(cell)
        row.dataset.processed = 'error'
      } else if (result.status === 'success') {
        const extraData = result.data || {}

        // Cập nhật danh sách header chính
        Object.keys(extraData).forEach((key) => {
          if (!state.extraHeaders.includes(key)) {
            state.extraHeaders.push(key)
          }
        })

        // Gán dữ liệu vào hàng để sử dụng ở bước đồng bộ hóa
        row.extraData = extraData
        row.dataset.processed = 'done'
      }

      // --- Đồng bộ hóa toàn bộ bảng (header và các dòng) ---
      // 1. Vẽ lại toàn bộ header bổ sung từ danh sách chính
      headerRow.querySelectorAll('.extra-header').forEach((th) => th.remove())
      state.extraHeaders.forEach((key) => {
        const th = document.createElement('th')
        th.textContent = key
        th.classList.add('extra-header')
        th.style.cssText = `border: 1px solid ${CONSTANTS.COLORS.BORDER}; padding: 8px; background-color: ${CONSTANTS.COLORS.HEADER_BACKGROUND}; font-weight: bold; text-align: left; position: sticky; top: 0;`
        headerRow.appendChild(th)
      })

      // 2. Đồng bộ hóa tất cả các dòng đã xử lý thành công
      const allRows = table.querySelectorAll('tbody tr')
      allRows.forEach((r) => {
        if (r.dataset.processed === 'done') {
          const rowData = r.extraData || {}
          r.querySelectorAll('.extra-cell').forEach((c) => c.remove()) // Xóa ô cũ
          // Thêm lại các ô mới theo đúng thứ tự header
          state.extraHeaders.forEach((headerKey) => {
            const value = rowData[headerKey] ?? ''
            const cell = createTableCell(value)
            cell.classList.add('extra-cell')
            r.appendChild(cell)
          })
        }
      })

      adjustPopupWidth()
    }

    // ==================== REFRESH MANAGEMENT ====================

    /**
     * Tạm dừng auto-refresh, thực thi một hàm async, sau đó tiếp tục refresh.
     * Điều này đảm bảo các tác vụ dài hơi như xử lý tab con không bị gián đoạn.
     * @param {Function} asyncFn - Hàm async để thực thi trong lúc refresh bị tạm dừng.
     */
    async function withRefreshSuspended(asyncFn) {
      const wasAlreadyPaused = state.isPaused
      if (!wasAlreadyPaused) {
        state.isPaused = true
        state.isProcessingUrls = true // Set processing state
        state.cancelProcessing = false // Reset cancellation flag
        if (window.csvCollectorRefreshIndicator) {
          // Cập nhật UI để cho biết một tiến trình đang chạy
          window.csvCollectorRefreshIndicator.textContent = 'Processing URLs...'
        }
        window.logToPopup('Auto-refresh suspended for URL processing.')
      }

      try {
        await asyncFn()
      } catch (error) {
        console.error(
          'CSV Collector: Error during suspended refresh task:',
          error
        )
        window.logToPopup(`Error during URL processing: ${error.message}`)
      } finally {
        if (!wasAlreadyPaused) {
          state.isPaused = false
          state.isProcessingUrls = false // Reset processing state
          // Reset lại đồng hồ đếm ngược để bắt đầu một chu kỳ mới
          state.timeLeft = state.currentInterval
          if (window.csvCollectorRefreshIndicator) {
            window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
          }
          // Check if it was cancelled to log the correct message
          if (state.cancelProcessing) {
            window.logToPopup('Processing cancelled. Auto-refresh resumed.')
          } else {
            window.logToPopup('Auto-refresh resumed.')
          }
        }
        state.cancelProcessing = false // Always reset at the end
      }
    }

    /**
     * Main refresh function - finds CSV, fetches, parses, and updates the table.
     */
    async function refreshData() {
      if (state.isRefreshing) {
        console.log('CSV Collector: Skipping refresh - already in progress.')
        return
      }

      try {
        state.isRefreshing = true
        window.logToPopup('Refreshing data...')

        const csvLink = findCsvDownloadLink()
        if (!csvLink) {
          window.logToPopup('Error: CSV download link not found on the page.')
          updateRefreshInterval(0)
          updateTableWithData([], window.csvCollectorTbody)
          return
        }

        window.logToPopup(`Found CSV link: ${csvLink}`)
        const csvData = await fetchAndParseCsv(csvLink)

        if (window.csvCollectorTbody) {
          updateTableWithData(csvData, window.csvCollectorTbody)
        }

        const recordCount = csvData.length > 1 ? csvData.length - 1 : 0
        updateRefreshInterval(recordCount)
        window.logToPopup(
          `Successfully processed ${recordCount} records at ${new Date().toLocaleTimeString()}`
        )
      } catch (error) {
        console.error('CSV Collector: Error in refreshData:', error)
        window.logToPopup(`Error refreshing data: ${error.message}`)
        updateTableWithData([], window.csvCollectorTbody)
      } finally {
        state.isRefreshing = false
        state.timeLeft = state.currentInterval
        if (window.csvCollectorRefreshIndicator) {
          window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
        }
      }
    }

    /**
     * Updates refresh interval based on whether data was found.
     * @param {number} recordCount - Number of data records found (excluding header).
     */
    function updateRefreshInterval(recordCount) {
      if (recordCount === 0) {
        state.currentInterval = settings.noDataInterval
        window.logToPopup(
          `No data found. Refresh interval set to ${state.currentInterval}s`
        )
      } else {
        state.currentInterval = settings.dataFoundInterval
        window.logToPopup(
          `Found ${recordCount} records. Refresh interval set to ${state.currentInterval}s`
        )
      }
    }

    /**
     * Starts the auto-refresh interval.
     */
    function startRefreshInterval() {
      if (state.refreshIntervalId) {
        clearInterval(state.refreshIntervalId)
      }
      state.timeLeft = state.currentInterval
      if (window.csvCollectorRefreshIndicator) {
        window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
      }

      state.refreshIntervalId = setInterval(() => {
        if (!state.isPaused) {
          state.timeLeft--
          if (state.timeLeft <= 0) {
            refreshData()
          } else if (window.csvCollectorRefreshIndicator) {
            window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
          }
        }
      }, 1000)
    }

    // ==================== POPUP CREATION & EVENT HANDLERS ====================
    // This section is largely adapted from oddsCollector_bwing.js for the UI.

    function setupDragAndDrop(popup, header) {
      const handleMouseDown = (e) => {
        // Cho phép kéo từ nền của header hoặc khu vực tiêu đề.
        // Các cú nhấp chuột vào các nút điều khiển sẽ có target khác
        // và không kích hoạt kéo, đây là hành vi mong muốn.
        if (e.target === header || e.target.closest('.title-container')) {
          state.isDragging = true
          state.startX = e.clientX
          state.startY = e.clientY
          const rect = popup.getBoundingClientRect()
          state.startLeft = rect.left
          state.startTop = rect.top
          e.preventDefault()
        }
      }
      const handleMouseMove = (e) => {
        if (!state.isDragging) return
        const dx = e.clientX - state.startX
        const dy = e.clientY - state.startY
        popup.style.left = `${state.startLeft + dx}px`
        popup.style.top = `${state.startTop + dy}px`
      }
      const handleMouseUp = () => {
        state.isDragging = false
      }
      header.addEventListener('mousedown', handleMouseDown)
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
    }

    function setupResize(popup, resizeHandle) {
      const handleMouseDown = (e) => {
        e.preventDefault()
        state.isResizing = true
        state.startX = e.clientX
        state.startY = e.clientY
        state.startWidth = popup.offsetWidth
        state.startHeight = popup.offsetHeight
      }
      const handleMouseMove = (e) => {
        if (!state.isResizing) return
        const dx = e.clientX - state.startX
        const dy = e.clientY - state.startY
        const newWidth = Math.max(
          CONSTANTS.POPUP.MIN_WIDTH,
          state.startWidth + dx
        )
        const newHeight = Math.max(
          CONSTANTS.POPUP.MIN_HEIGHT,
          state.startHeight + dy
        )
        popup.style.width = `${newWidth}px`
        popup.style.height = `${newHeight}px`
      }
      const handleMouseUp = () => {
        if (!state.isResizing) return
        state.isResizing = false
        state.originalWidth = popup.offsetWidth
        state.originalHeight = popup.offsetHeight
      }
      resizeHandle.addEventListener('mousedown', handleMouseDown)
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
    }

    function setupToggle(popup, toggleBtn, contentWrapper) {
      toggleBtn.addEventListener('click', () => {
        state.isCollapsed = !state.isCollapsed
        if (state.isCollapsed) {
          state.originalHeight = popup.offsetHeight
          popup.style.height = `${CONSTANTS.POPUP.HEADER_HEIGHT}px`
          contentWrapper.style.display = 'none'
          toggleBtn.textContent = '+'
        } else {
          popup.style.height = `${state.originalHeight}px`
          contentWrapper.style.display = 'flex'
          toggleBtn.textContent = '−'
        }
      })
    }

    function setupRefreshButton(refreshButton) {
      refreshButton.addEventListener('click', () => {
        refreshButton.classList.add('spinning')
        refreshData()
        setTimeout(
          () => refreshButton.classList.remove('spinning'),
          CONSTANTS.ANIMATIONS.SPIN_DURATION
        )
        window.logToPopup('Manual refresh triggered.')
      })
    }

    function setupRefreshIndicator(refreshIndicator, header, refreshButton) {
      refreshIndicator.addEventListener('click', () => {
        // NEW: Handle click during processing to cancel the operation.
        if (state.isProcessingUrls) {
          window.logToPopup('User requested to cancel URL processing.')
          state.cancelProcessing = true
          // The `finally` block in `withRefreshSuspended` will handle the UI
          // and state reset once the current async task finishes/aborts.
          return
        }

        if (state.isPaused) {
          state.isPaused = false
          header.classList.remove('flashing')
          refreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
          refreshButton.style.display = 'flex'
          window.logToPopup('Auto-refresh resumed.')
        } else {
          state.isPaused = true
          header.classList.add('flashing')
          refreshIndicator.textContent = 'Auto-refresh is paused'
          refreshButton.style.display = 'none'
          window.logToPopup('Auto-refresh paused.')
        }
      })
    }

    function createSettingsPanel() {
      const panel = document.createElement('div')
      panel.style.cssText = `
        position: absolute; top: ${
          CONSTANTS.POPUP.HEADER_HEIGHT + 4
        }px; left: 8px; background: white;
        border: 1px solid ${
          CONSTANTS.COLORS.BORDER
        }; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        border-radius: 4px; padding: 10px; z-index: 10000; min-width: 260px;
        display: none; font-size: 12px;`

      const field = (labelText, initValue, id) => {
        const row = document.createElement('div')
        row.style.cssText =
          'display: flex; align-items: center; justify-content: space-between; margin: 6px 0; gap: 8px;'
        const label = document.createElement('label')
        label.textContent = labelText
        label.setAttribute('for', id)
        const input = document.createElement('input')
        input.type = 'number'
        input.min = '1'
        input.step = '1'
        input.value = String(initValue)
        input.id = id
        input.style.cssText = 'width: 70px; padding: 2px 4px;'
        row.appendChild(label)
        row.appendChild(input)
        return { row, input }
      }

      const noData = field(
        'No data interval (s)',
        settings.noDataInterval,
        'cc-no-data'
      )
      const hasData = field(
        'Data found interval (s)',
        settings.dataFoundInterval,
        'cc-has-data'
      )
      const defInt = field(
        'Default interval (s)',
        settings.defaultInterval,
        'cc-default'
      )
      const reqDelay = field(
        'Request delay (ms)',
        settings.requestDelay,
        'cc-req-delay'
      )
      panel.appendChild(noData.row)
      panel.appendChild(hasData.row)
      panel.appendChild(defInt.row)
      panel.appendChild(reqDelay.row)

      const actions = document.createElement('div')
      actions.style.cssText =
        'margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px;'
      const cancel = document.createElement('button')
      cancel.textContent = 'Cancel'
      const save = document.createElement('button')
      save.textContent = 'Save'
      actions.appendChild(cancel)
      actions.appendChild(save)
      panel.appendChild(actions)

      panel._inputs = { noData, hasData, defInt, reqDelay }
      panel._buttons = { cancel, save }
      return panel
    }

    function setupSettingsInteractions(settingsBtn, panel) {
      const close = () => (panel.style.display = 'none')
      settingsBtn.addEventListener(
        'click',
        () =>
          (panel.style.display =
            panel.style.display === 'none' ? 'block' : 'none')
      )
      panel._buttons.cancel.addEventListener('click', close)
      panel._buttons.save.addEventListener('click', () => {
        settings.noDataInterval = Math.max(
          1,
          parseInt(panel._inputs.noData.input.value || '0', 10)
        )
        settings.dataFoundInterval = Math.max(
          1,
          parseInt(panel._inputs.hasData.input.value || '0', 10)
        )
        settings.defaultInterval = Math.max(
          1,
          parseInt(panel._inputs.defInt.input.value || '0', 10)
        )
        settings.requestDelay = Math.max(
          0,
          parseInt(panel._inputs.reqDelay.input.value || '3000', 10)
        )
        saveSettings(settings)
        refreshData() // Refresh with new settings
        close()
      })
    }

    function createTable() {
      const table = document.createElement('table')
      table.style.cssText = `width: 100%; border-collapse: collapse; font-size: 12px;`
      table.appendChild(document.createElement('thead'))
      table.appendChild(document.createElement('tbody'))
      return table
    }

    function injectStyles() {
      if (document.getElementById('csv-collector-styles')) return
      const style = document.createElement('style')
      style.id = 'csv-collector-styles'
      style.textContent = `
        #csv-collector-popup .spinning { animation: cc-spin 1s linear infinite; }
        @keyframes cc-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #csv-collector-popup .flashing { animation: cc-flash 1s infinite alternate; }
        @keyframes cc-flash { from { filter: brightness(1); } to { filter: brightness(1.2); } }
      `
      document.head.appendChild(style)
    }

    function createFloatingPopup() {
      injectStyles()
      const popup = document.createElement('div')
      popup.id = 'csv-collector-popup'
      popup.style.cssText = `
        position: fixed; top: 20px; left: 20px; width: ${CONSTANTS.POPUP.DEFAULT_WIDTH}px;
        min-width: ${CONSTANTS.POPUP.MIN_WIDTH}px; max-width: calc(100vw - 40px);
        max-height: calc(100vh - 40px); background: ${CONSTANTS.COLORS.BACKGROUND};
        border: 1px solid ${CONSTANTS.COLORS.BORDER}; border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 9999; display: flex;
        flex-direction: column; overflow: hidden;`

      const header = document.createElement('div')
      header.style.cssText = `
        padding: 8px; background: linear-gradient(to right, ${CONSTANTS.COLORS.HEADER_GRADIENT_START}, ${CONSTANTS.COLORS.HEADER_GRADIENT_END});
        border-bottom: 1px solid ${CONSTANTS.COLORS.BORDER}; cursor: move; display: flex;
        justify-content: space-between; align-items: center; user-select: none;
        height: ${CONSTANTS.POPUP.HEADER_HEIGHT}px; color: white;`

      const titleContainer = document.createElement('div')
      titleContainer.className = 'title-container'
      titleContainer.style.cssText = `display: flex; align-items: center; gap: 8px;`
      const title = document.createElement('span')
      title.textContent = 'CSV Collector'
      title.style.fontWeight = 'bold'
      titleContainer.appendChild(title)

      const controlsContainer = document.createElement('div')
      controlsContainer.style.cssText = `display: flex; align-items: center; gap: 8px;`

      const refreshIndicator = document.createElement('span')
      refreshIndicator.style.cssText = `font-size: 12px; color: #e0e0e0; cursor: pointer;`
      const refreshButton = document.createElement('button')
      refreshButton.innerHTML = '↻'
      refreshButton.title = 'Refresh now'
      refreshButton.style.cssText = `background: none; border: none; color: white; cursor: pointer; font-size: 16px;`
      const settingsBtn = document.createElement('button')
      settingsBtn.textContent = '⚙️'
      settingsBtn.title = 'Settings'
      settingsBtn.style.cssText = `background: none; border: none; color: white; cursor: pointer; font-size: 16px;`
      const toggleBtn = document.createElement('button')
      toggleBtn.textContent = '−'
      toggleBtn.title = 'Collapse'
      toggleBtn.style.cssText = `background: none; border: none; color: white; cursor: pointer; font-size: 18px;`

      controlsContainer.appendChild(refreshIndicator)
      controlsContainer.appendChild(refreshButton)
      controlsContainer.appendChild(settingsBtn)
      controlsContainer.appendChild(toggleBtn)
      header.appendChild(titleContainer)
      header.appendChild(controlsContainer)

      const contentWrapper = document.createElement('div')
      contentWrapper.style.cssText = `flex: 1; display: flex; flex-direction: column; min-height: 0; overflow: hidden;`
      const mainContent = document.createElement('div')
      mainContent.style.cssText = `flex: 1; padding: 10px; overflow: auto; min-height: 0;`
      const table = createTable()
      mainContent.appendChild(table)

      const logArea = document.createElement('textarea')
      logArea.style.cssText = `height: 80px; margin: 0 10px 10px 10px; padding: 5px; border: 1px solid ${CONSTANTS.COLORS.BORDER}; resize: vertical; flex-shrink: 0;`
      logArea.readOnly = true

      contentWrapper.appendChild(mainContent)
      contentWrapper.appendChild(logArea)

      const resizeHandle = document.createElement('div')
      resizeHandle.style.cssText = `position: absolute; right: 0; bottom: 0; width: 10px; height: 10px; cursor: se-resize;`

      const settingsPanel = createSettingsPanel()

      popup.appendChild(header)
      popup.appendChild(contentWrapper)
      popup.appendChild(resizeHandle)
      popup.appendChild(settingsPanel)

      // Store references on window
      window.csvCollectorTbody = table.querySelector('tbody')
      window.csvCollectorRefreshIndicator = refreshIndicator
      window.logToPopup = (message) => {
        const timestamp = new Date().toLocaleTimeString()
        logArea.value += `[${timestamp}] ${message}\n`
        logArea.scrollTop = logArea.scrollHeight
      }

      // Setup interactions
      setupDragAndDrop(popup, header)
      setupResize(popup, resizeHandle)
      setupToggle(popup, toggleBtn, contentWrapper)
      setupRefreshButton(refreshButton)
      setupRefreshIndicator(refreshIndicator, header, refreshButton)
      setupSettingsInteractions(settingsBtn, settingsPanel)

      state.originalHeight = popup.offsetHeight
      return popup
    }

    // ==================== INITIALIZATION ====================
    window.addEventListener('load', () => {
      try {
        const popup = createFloatingPopup()
        document.body.appendChild(popup)
        window.logToPopup('CSV Collector initialized.')

        refreshData()
        startRefreshInterval()
      } catch (error) {
        console.error('CSV Collector: Fatal error on initialization:', error)
      }
    })
  } catch (error) {
    console.error('CSV Collector: Fatal error in script:', error)
  }

  /**
   * Trích xuất dữ liệu từ một trang (document object).
   * @param {Document} doc - Document object của trang cần trích xuất dữ liệu.
   * @returns {object} - Một đối tượng chứa dữ liệu đã trích xuất.
   */
  function extractDataFromChildPage(doc) {
    // Helper function to get text content using XPath within the provided document.
    function getText(xpath, context) {
      try {
        // Use the passed 'doc' as the owner document for evaluation.
        const result = doc.evaluate(
          xpath,
          context,
          null,
          XPathResult.STRING_TYPE,
          null
        )
        // .stringValue will return the text content of the first matching node.
        return result.stringValue.trim()
      } catch (e) {
        console.error(`CSV Collector: Error evaluating XPath: ${xpath}`, e)
        return ''
      }
    }

    // Helper to extract just the number from strings like "10 Wins"
    const getNumber = (text) => (text.match(/\d+/) || [''])[0]

    // Define the final data structure.
    const extractedData = {}

    // 1. Find the root element for H2H content.
    const rootResult = doc.evaluate(
      "//main[contains(@id, 'h2h_content')]",
      doc,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null
    )
    const rootNode = rootResult.singleNodeValue

    if (!rootNode) {
      return { 'H2H Status': 'Root container not found' }
    }

    // 2. Find the H2H section within the root. We'll process the first one found.
    const h2hResult = doc.evaluate(
      "./section[contains(@class, 'h2h')]",
      rootNode,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null
    )
    const h2hNode = h2hResult.singleNodeValue

    if (!h2hNode) {
      return { 'H2H Status': 'H2H section not found' }
    }

    // 3. Get the content container which holds the stats.
    const contentNodeResult = doc.evaluate(
      "./div[contains(@class, 'content')]/div[contains(@class, 'row')]",
      h2hNode,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null
    )
    const contentNode = contentNodeResult.singleNodeValue

    if (!contentNode) {
      return { 'H2H Status': 'Stats content not found' }
    }

    // 4. Extract individual stats from the content container.
    // Note: Corrected user-provided XPaths to be relative and point to the correct teams.
    const matchesText = getText(
      "./div[contains(@class, 'teamA')]/p[contains(@class, 'stat')]/span",
      contentNode
    )
    const teamAWinText = getText(
      "./div[contains(@class, 'teamA')]/div[contains(@class, 'row')]/p[contains(@class, 'fl') and contains(@class, 'w50')]",
      contentNode
    )
    const drawText = getText(
      "./div[contains(@class, 'teamA')]/div[contains(@class, 'row')]/p[contains(@class, 'draw-line') and contains(@class, 'w100')]",
      contentNode
    )
    const teamBWinText = getText(
      "./div[contains(@class, 'teamA')]/div[contains(@class, 'row')]/p[contains(@class, 'fr') and contains(@class, 'w50')]",
      contentNode
    )

    // 5. Populate the final data object with extracted numbers.
    extractedData['H2H Matches'] = getNumber(matchesText)
    extractedData['TeamA Win'] = getNumber(teamAWinText)
    extractedData['Draw'] = getNumber(drawText)
    extractedData['TeamB Win'] = getNumber(teamBWinText)

    return extractedData
  }
})()
