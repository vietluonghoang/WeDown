// Tamper Monkey Script
// ==UserScript==
// @name         CSV Data Collector
// @namespace    http://tampermonkey.net/
// @version      0.1.0
// @description  Finds a CSV download link, parses the file, and displays it in a floating popup.
// @author       Viet Cat (Generated by Gemini)
// @match        https://footystats.org/
// @grant        GM_xmlhttpRequest
// @grant        GM.xmlHttpRequest
// @icon         https://www.google.com/s2/favicons?sz=64&domain=footystats.org
// @connect      *
// ==/UserScript==

/**
 * Main script function - wrapped in IIFE for scope isolation
 * This script creates a floating popup to collect and display data from a CSV file.
 * Features:
 * - Finds a CSV download link on the page (needs configuration).
 * - Fetches and parses the CSV data.
 * - Displays data in a dynamic table.
 * - Auto-refresh with configurable intervals.
 * - Manual refresh, pause/resume functionality.
 * - Draggable, resizable, and collapsible UI.
 */
;(function () {
  'use strict'

  try {
    console.log('CSV Collector: Script starting...')

    // ==================== CONSTANTS ====================
    const CONSTANTS = {
      REFRESH: {
        DEFAULT_INTERVAL: 10,
        NO_DATA_INTERVAL: 5,
        DATA_FOUND_INTERVAL: 60,
      },
      POPUP: {
        DEFAULT_WIDTH: 450,
        MIN_WIDTH: 300,
        MIN_HEIGHT: 200,
        HEADER_HEIGHT: 30,
      },
      COLORS: {
        HEADER_GRADIENT_START: '#005f73',
        HEADER_GRADIENT_END: '#0a9396',
        BACKGROUND: '#f8f9fa',
        BORDER: '#dee2e6',
        HEADER_BACKGROUND: '#e9ecef',
      },
      ANIMATIONS: {
        SPIN_DURATION: 1000,
      },
    }

    // ==================== SETTINGS (USER CONFIG) ====================
    const SETTINGS_STORAGE_KEY = 'csv_collector_settings_v1'
    const settings = loadSettings()

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_STORAGE_KEY)
        const parsed = raw ? JSON.parse(raw) : {}

        let reqDelay = parsed.requestDelay
        // Heuristic: if value is large, assume it's old data in ms and convert to s.
        if (reqDelay && Number(reqDelay) >= 1000) {
          console.log(
            `CSV Collector: Old requestDelay value (${reqDelay}ms) found. Converting to seconds.`
          )
          reqDelay = Number(reqDelay) / 1000
        }

        return {
          defaultInterval:
            Number(parsed.defaultInterval) > 0
              ? Number(parsed.defaultInterval)
              : CONSTANTS.REFRESH.DEFAULT_INTERVAL,
          noDataInterval:
            Number(parsed.noDataInterval) > 0
              ? Number(parsed.noDataInterval)
              : CONSTANTS.REFRESH.NO_DATA_INTERVAL,
          dataFoundInterval:
            Number(parsed.dataFoundInterval) > 0
              ? Number(parsed.dataFoundInterval)
              : CONSTANTS.REFRESH.DATA_FOUND_INTERVAL,
          requestDelay: Number(reqDelay) >= 0 ? Number(reqDelay) : 3, // Default 3s
        }
      } catch (_) {
        return {
          defaultInterval: CONSTANTS.REFRESH.DEFAULT_INTERVAL,
          noDataInterval: CONSTANTS.REFRESH.NO_DATA_INTERVAL,
          dataFoundInterval: CONSTANTS.REFRESH.DATA_FOUND_INTERVAL,
          requestDelay: 3,
        }
      }
    }

    function saveSettings(newSettings) {
      try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(newSettings))
      } catch (_) {}
    }

    // ==================== STATE MANAGEMENT ====================
    const state = {
      timeLeft: CONSTANTS.REFRESH.DEFAULT_INTERVAL,
      refreshIntervalId: null,
      isPaused: false,
      isRefreshing: false,
      currentInterval: CONSTANTS.REFRESH.DEFAULT_INTERVAL,
      isDragging: false,
      isResizing: false,
      isCollapsed: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startTop: 0,
      startWidth: 0,
      startHeight: 0,
      originalWidth: CONSTANTS.POPUP.DEFAULT_WIDTH,
      originalHeight: 0,
      lastRequestStartTime: 0, // Timestamp of the last background request start
      lastDataSignature: '',
      lastRecordCount: 0,
      isProcessingUrls: false, // To specifically track this background task
      cancelProcessing: false, // Flag to signal cancellation
      extraHeaders: [], // Stores the keys of extra columns in order
      userHasResized: false,
      autoScrollLog: true,
    }

    // ==================== UTILITY FUNCTIONS ====================
    /**
     * Creates a delay for a specified number of milliseconds.
     * @param {number} ms - The number of milliseconds to wait.
     * @returns {Promise<void>}
     */
    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms))
    }

    // ==================== CSV PROCESSING ====================

    /**
     * Finds the CSV download link on the page.
     * NOTE: You MUST configure the selector to match the target website.
     * @returns {string|null} The URL of the CSV file or null if not found.
     */
    function findCsvDownloadLink() {
      // ================== USER CONFIGURATION ==================
      // XPath để tìm thẻ a có chứa link download.
      const xpath =
        "//div[@id = 'content']/div/div/div/div/a[./i[contains(@class,'download')]]"
      // ========================================================

      try {
        const result = document.evaluate(
          xpath,
          document,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        )
        const linkElement = result.singleNodeValue

        if (linkElement && linkElement.href) {
          // Đảm bảo link là một URL tuyệt đối (absolute)
          return new URL(linkElement.href, window.location.href).href
        }
      } catch (error) {
        console.error(
          'CSV Collector: Lỗi khi thực thi XPath để tìm link download:',
          error
        )
      }
      return null
    }

    /**
     * Fetches a CSV file and parses it into an array of arrays.
     * @param {string} url - The URL of the CSV file.
     * @returns {Promise<Array<Array<string>>>} A promise that resolves to the parsed data.
     */
    function fetchAndParseCsv(url) {
      return new Promise((resolve, reject) => {
        window.logToPopup(`Fetching CSV from ${url}...`)
        // Use GM_xmlhttpRequest for cross-origin requests
        GM_xmlhttpRequest({
          method: 'GET',
          url: url,
          onload: function (response) {
            if (response.status >= 200 && response.status < 300) {
              window.logToPopup('CSV file fetched successfully. Parsing...')
              const parsedData = parseCsvText(response.responseText)
              resolve(parsedData)
            } else {
              reject(
                new Error(`Failed to fetch CSV: Status ${response.status}`)
              )
            }
          },
          onerror: function (error) {
            reject(new Error(`Network error fetching CSV: ${error.details}`))
          },
        })
      })
    }

    /**
     * Parses a string of CSV text into an array of arrays.
     * Handles quoted fields containing commas.
     * @param {string} csvText - The raw CSV text.
     * @returns {Array<Array<string>>} The parsed data.
     */
    function parseCsvText(csvText) {
      const rows = []
      if (!csvText) return rows

      const lines = csvText.trim().split('\n')
      for (const line of lines) {
        const row = []
        let currentField = ''
        let inQuotes = false
        for (let i = 0; i < line.length; i++) {
          const char = line[i]
          if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
            // Handles standard quotes, ignores escaped quotes
            inQuotes = !inQuotes
          } else if (char === ',' && !inQuotes) {
            row.push(currentField.trim())
            currentField = ''
          } else {
            currentField += char
          }
        }
        row.push(currentField.trim())
        rows.push(row)
      }
      return rows
    }

    // ==================== UI & TABLE FUNCTIONS ====================

    /**
     * Creates a table cell with consistent styling.
     * @param {string} content - Cell content.
     * @returns {HTMLElement} - Styled table cell.
     */
    function createTableCell(content) {
      const td = document.createElement('td')
      td.textContent = content
      td.style.cssText = `
        border: 1px solid ${CONSTANTS.COLORS.BORDER};
        padding: 6px 8px;
        text-align: left;
        white-space: nowrap;
      `
      return td
    }

    /**
     * Updates the popup table with parsed CSV data.
     * @param {Array<Array<string>>} data - Array of rows, where each row is an array of strings.
     * @param {HTMLElement} tbody - Table body element to update.
     */
    function updateTableWithData(data, tbody, force = false) {
      try {
        const signature = JSON.stringify(data)
        // If not forced and data is the same, skip the update.
        if (!force && signature === state.lastDataSignature) {
          window.logToPopup('Data unchanged, skipping table update.')
          return
        }
        state.lastDataSignature = signature

        const table = tbody.closest('table')
        if (!table) return

        const thead = table.querySelector('thead')
        tbody.innerHTML = ''
        thead.innerHTML = ''

        if (!data || data.length === 0) {
          // Cập nhật colspan để khớp với số cột sẽ hiển thị (9 cột)
          tbody.innerHTML = '<tr><td colspan="9">No data to display.</td></tr>'
          return
        }

        // ================== USER CONFIGURATION ==================
        // Chỉ định các cột (theo index, bắt đầu từ 0) muốn hiển thị.
        // Tương ứng với cột 2,3,4,5,6,46,47,48,107 trong file CSV (do index bắt đầu từ 0).
        const columnsToShow = [1, 2, 3, 4, 5, 14, 45, 46, 47, 49, 106]
        // ========================================================

        // Create header row
        const headerRow = document.createElement('tr')
        const headers = data[0]
        columnsToShow.forEach((colIndex) => {
          // Lấy header, nếu không tồn tại thì dùng tên mặc định
          const headerText = headers[colIndex] ?? `Cột ${colIndex + 1}`
          const th = document.createElement('th')
          th.textContent = headerText
          th.style.cssText = `
            border: 1px solid ${CONSTANTS.COLORS.BORDER};
            padding: 8px;
            background-color: ${CONSTANTS.COLORS.HEADER_BACKGROUND};
            font-weight: bold;
            text-align: left;
            position: sticky;
            top: 0;
          `
          headerRow.appendChild(th)
        })
        thead.appendChild(headerRow)

        // Create data rows
        const dataRows = data.slice(1)
        dataRows.forEach((rowData) => {
          const tr = document.createElement('tr')
          columnsToShow.forEach((colIndex) => {
            const headerText = headers[colIndex] ?? ''
            // Dùng ?? '' để đảm bảo an toàn nếu dữ liệu cột không tồn tại
            const cellData = rowData[colIndex] ?? ''

            // Check if this is the URL column
            if (
              headerText === 'Match FootyStats URL' &&
              (cellData.startsWith('http') || cellData.startsWith('/'))
            ) {
              const td = createTableCell('') // Create an empty cell
              const link = document.createElement('a')
              link.href = new URL(cellData, window.location.href).href
              link.textContent = 'View'
              link.target = '_blank' // Open in a new tab
              link.rel = 'noopener noreferrer' // Security best practice
              td.appendChild(link)
              tr.appendChild(td)
            } else {
              tr.appendChild(createTableCell(cellData))
            }
          })
          tbody.appendChild(tr)
        })

        window.logToPopup(`Table updated with ${dataRows.length} rows.`)
        adjustPopupWidth()
      } catch (error) {
        console.error('CSV Collector: Error in updateTableWithData:', error)
        window.logToPopup(`Error updating table: ${error.message}`)
      }
    }

    /**
     * Adjusts popup width based on table content.
     */
    function adjustPopupWidth() {
      if (state.userHasResized) return

      const table = document.querySelector('#csv-collector-popup table')
      if (!table) return

      const popup = document.getElementById('csv-collector-popup')
      if (popup) {
        const rect = popup.getBoundingClientRect()
        // Required width is table's scroll width + padding of mainContent (10px each side).
        const requiredWidth = table.scrollWidth + 20
        // Max width is viewport width minus current left position.
        const maxWidth = window.innerWidth - rect.left

        const newWidth = Math.min(
          Math.max(requiredWidth, CONSTANTS.POPUP.MIN_WIDTH),
          maxWidth
        )
        popup.style.width = `${newWidth}px`
        state.originalWidth = newWidth
      }
    }

    /**
     * Tuần tự duyệt qua các dòng của bảng, tìm URL và xử lý chúng trong tab mới.
     * @param {HTMLElement} tbody - Phần thân của bảng chứa các dòng dữ liệu.
     */
    async function processTableRowsForUrls(tbody) {
      // Thêm một log để debug dễ hơn, cho biết quá trình bắt đầu
      console.log('CSV Collector: Starting processTableRowsForUrls...')
      window.logToPopup('Starting to process rows for additional data...')
      const rows = tbody.querySelectorAll('tr')
      window.logToPopup(`Found ${rows.length} rows to process.`)
      for (const row of rows) {
        // Check for cancellation signal at the start of each iteration
        if (state.cancelProcessing) {
          window.logToPopup('URL processing was cancelled by the user.')
          // Reset the 'loading' status for any rows that were in progress
          tbody
            .querySelectorAll("tr[data-processed='loading']")
            .forEach((r) => {
              r.dataset.processed = '' // Allow reprocessing next time
              const statusCell = r.querySelector('.status-cell')
              if (statusCell) statusCell.remove()
            })
          break // Exit the loop
        }

        // Bỏ qua nếu dòng đã được xử lý hoặc đang được xử lý
        if (row.dataset.processed) continue

        // Đánh dấu là đang xử lý để tránh lặp lại
        row.dataset.processed = 'loading'

        // Lấy tên đội nhà/khách từ các ô của bảng để so sánh
        const homeTeamNameCsv = row.cells[3]
          ? row.cells[3].textContent.trim()
          : null
        const awayTeamNameCsv = row.cells[4]
          ? row.cells[4].textContent.trim()
          : null

        const lastCell = row.cells[row.cells.length - 1]
        if (!lastCell) continue

        // Lấy URL từ thẻ <a> nếu có, nếu không thì lấy text content
        const linkElement = lastCell.querySelector('a[href]')
        const url = linkElement ? linkElement.href : lastCell.textContent.trim()

        // Kiểm tra xem nội dung có phải là một URL tuyệt đối hoặc một đường dẫn tương đối (bắt đầu bằng /)
        if (url.startsWith('http') || url.startsWith('/')) {
          try {
            // --- DYNAMIC DELAY LOGIC ---
            // Wait until the configured delay has passed since the last request.
            const requiredDelay = (settings.requestDelay || 3) * 1000
            const timeSinceLastRequest = Date.now() - state.lastRequestStartTime

            if (
              state.lastRequestStartTime > 0 &&
              timeSinceLastRequest < requiredDelay
            ) {
              const timeToWait = requiredDelay - timeSinceLastRequest
              if (timeToWait > 0) {
                window.logToPopup(
                  `Waiting for ${(timeToWait / 1000).toFixed(1)}s...`
                )
                await delay(timeToWait)
              }
            }
            // Mark the start time of the new request
            state.lastRequestStartTime = Date.now()

            window.logToPopup(
              `[${row.rowIndex}/${rows.length}] Processing URL: ${url}`
            )
            updateTableRowWithExtraData(row, { status: 'loading' })

            // Thay thế việc mở tab mới bằng cách fetch dữ liệu trong nền
            const extraData = await processUrlInBackground(
              url,
              homeTeamNameCsv,
              awayTeamNameCsv
            )
            updateTableRowWithExtraData(row, {
              status: 'success',
              data: extraData,
            })
            window.logToPopup(
              `[${row.rowIndex}/${rows.length}] Successfully fetched data for ${url}`
            )
          } catch (error) {
            updateTableRowWithExtraData(row, {
              status: 'error',
              message: error.message,
            })
            console.error(`Failed to fetch data for ${url}: ${error.message}`)
          }
        } else {
          // Nếu không phải URL, đánh dấu là đã hoàn thành
          row.dataset.processed = 'done'
        }
      }
      if (!state.cancelProcessing) {
        window.logToPopup('Finished processing all rows.')
      }
    }

    /**
     * Fetches a URL in the background, parses its HTML, and extracts data.
     * Implements a retry mechanism for 429 (Too Many Requests) errors.
     * @param {string} url - The URL to process (can be relative or absolute).
     * @returns {Promise<object>} - A promise that resolves with the extracted data.
     */
    function processUrlInBackground(url, homeTeamNameCsv, awayTeamNameCsv) {
      return new Promise(async (resolve, reject) => {
        const absoluteUrl = new URL(url, window.location.href).href
        const maxRetries = 3
        // The delay for retries will be managed locally and won't affect the global setting.
        let retryDelay = (settings.requestDelay || 3) * 1000

        for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
          try {
            const response = await new Promise((res, rej) => {
              GM_xmlhttpRequest({
                method: 'GET',
                url: absoluteUrl,
                onload: function (response) {
                  res(response)
                },
                onerror: function (error) {
                  rej(
                    new Error(
                      `Network error fetching ${absoluteUrl}: ${error.details}`
                    )
                  )
                },
              })
            })

            if (response.status >= 200 && response.status < 300) {
              // Success
              try {
                const parser = new DOMParser()
                const doc = parser.parseFromString(
                  response.responseText,
                  'text/html'
                )
                const extraData = extractDataFromChildPage(
                  doc,
                  homeTeamNameCsv,
                  awayTeamNameCsv
                )
                resolve(extraData)
                return // Exit successfully
              } catch (e) {
                reject(
                  new Error(
                    `Failed to parse HTML for ${absoluteUrl}: ${e.message}`
                  )
                )
                return // Parsing error, do not retry
              }
            } else if (response.status === 429) {
              // Retryable error
              if (attempt > maxRetries) {
                reject(
                  new Error(`Status 429. Failed after ${maxRetries} retries.`)
                )
                return
              }
              window.logToPopup(
                `Status 429. Retrying in ${(retryDelay / 1000).toFixed(
                  1
                )}s... (${maxRetries - attempt + 1} retries left)`
              )
              await delay(retryDelay)
              retryDelay *= 2 // Double the delay for the next attempt
            } else {
              // Any other error status is final
              reject(new Error(`Status ${response.status}`))
              return
            }
          } catch (error) {
            // Network error from GM_xmlhttpRequest
            reject(error)
            return
          }
        }
      })
    }

    /**
     * Cập nhật một dòng trong bảng với dữ liệu bổ sung hoặc trạng thái.
     * @param {HTMLElement} row - Phần tử <tr> cần cập nhật.
     * @param {object} result - Kết quả xử lý, chứa trạng thái và dữ liệu.
     */
    function updateTableRowWithExtraData(row, result) {
      const table = row.closest('table')
      if (!table) return
      const thead = table.querySelector('thead')
      const headerRow = thead.querySelector('tr')

      // Xóa các ô trạng thái và dữ liệu bổ sung cũ để vẽ lại cho đúng thứ tự
      row
        .querySelectorAll('.status-cell, .extra-cell')
        .forEach((c) => c.remove())

      if (result.status === 'loading') {
        const cell = createTableCell('Loading...')
        cell.classList.add('status-cell')
        row.appendChild(cell)
      } else if (result.status === 'error') {
        const cell = createTableCell(`Error: ${result.message}`)
        cell.style.color = 'red'
        cell.classList.add('status-cell')
        row.appendChild(cell)
        row.dataset.processed = 'error'
      } else if (result.status === 'success') {
        const extraData = result.data || {}

        // Helper để làm phẳng object, tạo key dạng "Parent Key"
        const flattenObject = (obj, prefix = '') =>
          Object.keys(obj).reduce((acc, k) => {
            const pre = prefix.length ? prefix + ' ' : ''
            if (
              typeof obj[k] === 'object' &&
              obj[k] !== null &&
              !Array.isArray(obj[k])
            ) {
              Object.assign(acc, flattenObject(obj[k], pre + k))
            } else {
              acc[pre + k] = obj[k]
            }
            return acc
          }, {})

        const flattenedData = flattenObject(extraData)

        // Cập nhật danh sách header chính từ dữ liệu đã được làm phẳng
        Object.keys(flattenedData).forEach((key) => {
          if (!state.extraHeaders.includes(key)) {
            state.extraHeaders.push(key)
          }
        })

        // Gán dữ liệu đã được làm phẳng vào hàng
        row.extraData = flattenedData
        row.dataset.processed = 'done'
      }

      // --- Đồng bộ hóa toàn bộ bảng (header và các dòng) ---
      // 1. Vẽ lại toàn bộ header bổ sung từ danh sách chính
      const hiddenHeaders = new Set([
        'MP teamAName',
        'MP teamBName',
        'H2H teamAName',
        'H2H teamBName',
        'Neo TeamAName',
        'Neo TeamBName',
      ])
      headerRow.querySelectorAll('.extra-header').forEach((th) => th.remove())
      state.extraHeaders.forEach((key) => {
        if (hiddenHeaders.has(key)) return // Tạm ẩn cột
        const th = document.createElement('th')
        th.textContent = key
        th.classList.add('extra-header')
        th.style.cssText = `border: 1px solid ${CONSTANTS.COLORS.BORDER}; padding: 8px; background-color: ${CONSTANTS.COLORS.HEADER_BACKGROUND}; font-weight: bold; text-align: left; position: sticky; top: 0;`
        headerRow.appendChild(th)
      })

      // 2. Đồng bộ hóa tất cả các dòng đã xử lý thành công
      const allRows = table.querySelectorAll('tbody tr')
      allRows.forEach((r) => {
        if (r.dataset.processed === 'done') {
          const rowData = r.extraData || {}
          r.querySelectorAll('.extra-cell').forEach((c) => c.remove()) // Xóa ô cũ
          // Thêm lại các ô mới theo đúng thứ tự header
          state.extraHeaders.forEach((headerKey) => {
            if (hiddenHeaders.has(headerKey)) return // Tạm ẩn ô
            const value = rowData[headerKey] ?? ''
            const cell = createTableCell(value)
            cell.classList.add('extra-cell')
            r.appendChild(cell)
          })
        }
      })

      adjustPopupWidth()
    }

    // ==================== REFRESH MANAGEMENT ====================

    /**
     * Tạm dừng auto-refresh, thực thi một hàm async, sau đó tiếp tục refresh.
     * Điều này đảm bảo các tác vụ dài hơi như xử lý tab con không bị gián đoạn.
     * @param {Function} asyncFn - Hàm async để thực thi trong lúc refresh bị tạm dừng.
     */
    async function withRefreshSuspended(asyncFn) {
      const wasAlreadyPaused = state.isPaused
      if (!wasAlreadyPaused) {
        state.isPaused = true
        state.isProcessingUrls = true // Set processing state
        state.cancelProcessing = false // Reset cancellation flag
        if (window.csvCollectorRefreshIndicator) {
          // Cập nhật UI để cho biết một tiến trình đang chạy
          window.csvCollectorRefreshIndicator.textContent = 'Processing URLs...'
        }
        window.logToPopup('Auto-refresh suspended for URL processing.')
      }

      try {
        await asyncFn()
      } catch (error) {
        console.error(
          'CSV Collector: Error during suspended refresh task:',
          error
        )
        window.logToPopup(`Error during URL processing: ${error.message}`)
      } finally {
        if (!wasAlreadyPaused) {
          state.isPaused = false
          state.isProcessingUrls = false // Reset processing state
          // Reset lại đồng hồ đếm ngược để bắt đầu một chu kỳ mới
          state.timeLeft = state.currentInterval
          if (window.csvCollectorRefreshIndicator) {
            window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
          }
          // Check if it was cancelled to log the correct message
          if (state.cancelProcessing) {
            window.logToPopup('Processing cancelled. Auto-refresh resumed.')
          } else {
            window.logToPopup('Auto-refresh resumed.')
          }
        }
        state.cancelProcessing = false // Always reset at the end
      }
    }

    /**
     * Main refresh function - finds CSV, fetches, parses, and updates the table.
     */
    async function refreshData(force = false) {
      if (state.isRefreshing) {
        console.log('CSV Collector: Skipping refresh - already in progress.')
        return
      }

      try {
        state.isRefreshing = true
        window.logToPopup('Refreshing data...')

        const csvLink = findCsvDownloadLink()
        if (!csvLink) {
          // Thêm log lỗi vào console để dễ thấy hơn
          console.error(
            'CSV Collector: Could not find the CSV download link. Check the XPath selector in findCsvDownloadLink().'
          )
          window.logToPopup('Error: CSV download link not found on the page.')
          updateRefreshInterval(0)
          updateTableWithData([], window.csvCollectorTbody)
          return
        }

        window.logToPopup(`Found CSV link: ${csvLink}`)
        const csvData = await fetchAndParseCsv(csvLink)

        if (window.csvCollectorTbody) {
          updateTableWithData(csvData, window.csvCollectorTbody, force)
          // Bắt đầu xử lý các dòng trong bảng, tạm dừng refresh trong khi thực hiện.
          // Việc này được gọi ở đây để đảm bảo nó chạy cho cả refresh tự động và thủ công.
          setTimeout(
            () =>
              withRefreshSuspended(() =>
                processTableRowsForUrls(window.csvCollectorTbody)
              ),
            500
          )
        }

        const recordCount = csvData.length > 1 ? csvData.length - 1 : 0
        state.lastRecordCount = recordCount
        updateRefreshInterval(recordCount)
        window.logToPopup(
          `Successfully processed ${recordCount} records at ${new Date().toLocaleTimeString()}`
        )
      } catch (error) {
        console.error('CSV Collector: Error in refreshData:', error)
        window.logToPopup(`Error refreshing data: ${error.message}`)
        updateTableWithData([], window.csvCollectorTbody)
      } finally {
        state.isRefreshing = false
        state.timeLeft = state.currentInterval
        if (window.csvCollectorRefreshIndicator) {
          window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
        }
      }
    }

    /**
     * Updates refresh interval based on whether data was found.
     * @param {number} recordCount - Number of data records found (excluding header).
     */
    function updateRefreshInterval(recordCount) {
      if (recordCount === 0) {
        state.currentInterval = settings.noDataInterval
        window.logToPopup(
          `No data found. Refresh interval set to ${state.currentInterval}s`
        )
      } else {
        state.currentInterval = settings.dataFoundInterval
        window.logToPopup(
          `Found ${recordCount} records. Refresh interval set to ${state.currentInterval}s`
        )
      }
    }

    /**
     * Starts the auto-refresh interval.
     */
    function startRefreshInterval() {
      if (state.refreshIntervalId) {
        clearInterval(state.refreshIntervalId)
      }
      state.timeLeft = state.currentInterval
      if (window.csvCollectorRefreshIndicator) {
        window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
      }

      state.refreshIntervalId = setInterval(() => {
        if (!state.isPaused) {
          state.timeLeft--
          if (state.timeLeft <= 0) {
            refreshData()
          } else if (window.csvCollectorRefreshIndicator) {
            window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
          }
        }
      }, 1000)
    }

    // ==================== POPUP CREATION & EVENT HANDLERS ====================
    // This section is largely adapted from oddsCollector_bwing.js for the UI.

    function setupDragAndDrop(popup, header) {
      const handleMouseDown = (e) => {
        // Cho phép kéo từ nền của header hoặc khu vực tiêu đề.
        // Các cú nhấp chuột vào các nút điều khiển sẽ có target khác
        // và không kích hoạt kéo, đây là hành vi mong muốn.
        if (e.target === header || e.target.closest('.title-container')) {
          state.isDragging = true
          state.startX = e.clientX
          state.startY = e.clientY
          const rect = popup.getBoundingClientRect()
          state.startLeft = rect.left
          state.startTop = rect.top
          e.preventDefault()
        }
      }
      const handleMouseMove = (e) => {
        if (!state.isDragging) return
        const dx = e.clientX - state.startX
        const dy = e.clientY - state.startY

        let newLeft = state.startLeft + dx
        let newTop = state.startTop + dy

        // Đảm bảo popup không bị kéo ra ngoài viewport
        const maxLeft = window.innerWidth - popup.offsetWidth
        const maxTop = window.innerHeight - popup.offsetHeight
        newLeft = Math.max(0, Math.min(newLeft, maxLeft))
        newTop = Math.max(0, Math.min(newTop, maxTop))

        popup.style.left = `${newLeft}px`
        popup.style.top = `${newTop}px`
      }
      const handleMouseUp = () => {
        state.isDragging = false
      }
      header.addEventListener('mousedown', handleMouseDown)
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
    }

    function setupResize(popup, resizeHandle) {
      const handleMouseDown = (e) => {
        e.preventDefault()
        state.isResizing = true
        state.startX = e.clientX
        state.startY = e.clientY
        state.startWidth = popup.offsetWidth
        state.startHeight = popup.offsetHeight
      }
      const handleMouseMove = (e) => {
        if (!state.isResizing) return
        const dx = e.clientX - state.startX
        const dy = e.clientY - state.startY

        const rect = popup.getBoundingClientRect()

        // Đảm bảo kích thước mới không vượt quá viewport
        const maxWidth = window.innerWidth - rect.left - 20
        const maxHeight = window.innerHeight - rect.top - 20

        const newWidth = Math.min(
          Math.max(CONSTANTS.POPUP.MIN_WIDTH, state.startWidth + dx),
          maxWidth
        )
        const newHeight = Math.min(
          Math.max(CONSTANTS.POPUP.MIN_HEIGHT, state.startHeight + dy),
          maxHeight
        )

        popup.style.width = `${newWidth}px`
        popup.style.height = `${newHeight}px`
      }
      const handleMouseUp = () => {
        if (!state.isResizing) return
        state.isResizing = false
        state.originalWidth = popup.offsetWidth
        state.originalHeight = popup.offsetHeight
        state.userHasResized = true
      }
      resizeHandle.addEventListener('mousedown', handleMouseDown)
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
    }

    function setupToggle(popup, toggleBtn, contentWrapper) {
      toggleBtn.addEventListener('click', () => {
        state.isCollapsed = !state.isCollapsed
        if (state.isCollapsed) {
          // Lưu lại kích thước hiện tại trước khi thu gọn
          state.originalWidth = popup.offsetWidth
          state.originalHeight = popup.offsetHeight

          // Chiều rộng tối thiểu để hiển thị các nút điều khiển trên header
          const minHeaderWidth = 350 // px

          popup.style.height = `${CONSTANTS.POPUP.HEADER_HEIGHT}px`
          popup.style.width = `${minHeaderWidth}px`
          popup.style.minWidth = `${minHeaderWidth}px`
          popup.style.minHeight = `${CONSTANTS.POPUP.HEADER_HEIGHT}px`

          contentWrapper.style.display = 'none'
          toggleBtn.textContent = '+'
          toggleBtn.title = 'Expand'
        } else {
          // Khôi phục lại kích thước ban đầu
          popup.style.height = `${
            state.originalHeight || CONSTANTS.POPUP.MIN_HEIGHT
          }px`
          popup.style.width = `${
            state.originalWidth || CONSTANTS.POPUP.DEFAULT_WIDTH
          }px`
          popup.style.minHeight = `${CONSTANTS.POPUP.MIN_HEIGHT}px`
          popup.style.minWidth = `${CONSTANTS.POPUP.MIN_WIDTH}px`

          contentWrapper.style.display = 'flex'
          toggleBtn.textContent = '−'
          toggleBtn.title = 'Collapse'
        }
      })
    }

    function setupRefreshButton(refreshButton) {
      refreshButton.addEventListener('click', () => {
        refreshButton.classList.add('spinning')
        refreshData(true) // Force a full refresh
        setTimeout(
          () => refreshButton.classList.remove('spinning'),
          CONSTANTS.ANIMATIONS.SPIN_DURATION
        )
        window.logToPopup('Manual refresh triggered.')
      })
    }

    function setupRefreshIndicator(refreshIndicator, header, refreshButton) {
      refreshIndicator.addEventListener('click', () => {
        // NEW: Handle click during processing to cancel the operation.
        if (state.isProcessingUrls) {
          window.logToPopup('User requested to cancel URL processing.')
          state.cancelProcessing = true
          // The `finally` block in `withRefreshSuspended` will handle the UI
          // and state reset once the current async task finishes/aborts.
          return
        }

        if (state.isPaused) {
          state.isPaused = false
          header.classList.remove('flashing')
          refreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
          refreshButton.style.display = 'flex'
          window.logToPopup('Auto-refresh resumed.')
        } else {
          state.isPaused = true
          header.classList.add('flashing')
          refreshIndicator.textContent = 'Auto-refresh is paused'
          refreshButton.style.display = 'none'
          window.logToPopup('Auto-refresh paused.')
        }
      })
    }

    function createSettingsPanel() {
      const panel = document.createElement('div')
      panel.style.cssText = `
        position: absolute; top: ${
          CONSTANTS.POPUP.HEADER_HEIGHT + 4
        }px; left: 8px; background: white;
        border: 1px solid ${
          CONSTANTS.COLORS.BORDER
        }; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        border-radius: 4px; padding: 10px; z-index: 10000; min-width: 260px;
        display: none; font-size: 12px;`

      const field = (labelText, initValue, id) => {
        const row = document.createElement('div')
        row.style.cssText =
          'display: flex; align-items: center; justify-content: space-between; margin: 6px 0; gap: 8px;'
        const label = document.createElement('label')
        label.textContent = labelText
        label.setAttribute('for', id)
        const input = document.createElement('input')
        input.type = 'number'
        input.min = id === 'cc-req-delay' ? '0' : '0.5'
        input.step = 'any'
        input.value = String(initValue)
        input.id = id
        input.style.cssText = 'width: 70px; padding: 2px 4px;'
        row.appendChild(label)
        row.appendChild(input)
        return { row, input }
      }

      const noData = field(
        'No data interval (s)',
        settings.noDataInterval,
        'cc-no-data'
      )
      const hasData = field(
        'Data found interval (s)',
        settings.dataFoundInterval,
        'cc-has-data'
      )
      const defInt = field(
        'Default interval (s)',
        settings.defaultInterval,
        'cc-default'
      )
      const reqDelay = field(
        'Request delay (s)',
        settings.requestDelay,
        'cc-req-delay'
      )
      panel.appendChild(noData.row)
      panel.appendChild(hasData.row)
      panel.appendChild(defInt.row)
      panel.appendChild(reqDelay.row)

      const actions = document.createElement('div')
      actions.style.cssText =
        'margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px;'
      const cancel = document.createElement('button')
      cancel.textContent = 'Cancel'
      const save = document.createElement('button')
      save.textContent = 'Save'
      actions.appendChild(cancel)
      actions.appendChild(save)
      panel.appendChild(actions)

      panel._inputs = { noData, hasData, defInt, reqDelay }
      panel._buttons = { cancel, save }
      return panel
    }

    function setupSettingsInteractions(settingsBtn, panel) {
      const close = () => (panel.style.display = 'none')
      settingsBtn.addEventListener(
        'click',
        () =>
          (panel.style.display =
            panel.style.display === 'none' ? 'block' : 'none')
      )
      panel._buttons.cancel.addEventListener('click', close)
      panel._buttons.save.addEventListener('click', () => {
        const newNoData = parseFloat(panel._inputs.noData.input.value)
        if (!isNaN(newNoData))
          settings.noDataInterval = Math.max(0.5, newNoData)

        const newHasData = parseFloat(panel._inputs.hasData.input.value)
        if (!isNaN(newHasData))
          settings.dataFoundInterval = Math.max(0.5, newHasData)

        const newDefInt = parseFloat(panel._inputs.defInt.input.value)
        if (!isNaN(newDefInt))
          settings.defaultInterval = Math.max(0.5, newDefInt)

        const newReqDelay = parseFloat(panel._inputs.reqDelay.input.value)
        if (!isNaN(newReqDelay))
          settings.requestDelay = Math.max(0, newReqDelay)

        saveSettings(settings)

        // Only update intervals if not processing URLs in the background
        if (!state.isProcessingUrls) {
          updateRefreshInterval(state.lastRecordCount || 0)
          // If not paused, reset the countdown timer
          if (!state.isPaused) {
            state.timeLeft = state.currentInterval
            if (window.csvCollectorRefreshIndicator) {
              window.csvCollectorRefreshIndicator.textContent = `Auto-refresh in: ${state.timeLeft}s`
            }
          }
        }
        window.logToPopup('Settings saved.')
        close()
      })
    }

    function createTable() {
      const table = document.createElement('table')
      table.style.cssText = `width: 100%; border-collapse: collapse; font-size: 12px;`
      table.appendChild(document.createElement('thead'))
      table.appendChild(document.createElement('tbody'))
      return table
    }

    function injectStyles() {
      if (document.getElementById('csv-collector-styles')) return
      const style = document.createElement('style')
      style.id = 'csv-collector-styles'
      style.textContent = `
        #csv-collector-popup .spinning { animation: cc-spin 1s linear infinite; }
        @keyframes cc-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #csv-collector-popup .flashing { animation: cc-flash 1s infinite alternate; }
        @keyframes cc-flash { from { filter: brightness(1); } to { filter: brightness(1.2); } }
      `
      document.head.appendChild(style)
    }

    function createFloatingPopup() {
      injectStyles()
      const popup = document.createElement('div')
      popup.id = 'csv-collector-popup'
      popup.style.cssText = `
        position: fixed; top: 70px; left: 20px; width: ${CONSTANTS.POPUP.DEFAULT_WIDTH}px;
        min-width: ${CONSTANTS.POPUP.MIN_WIDTH}px; max-width: calc(100vw - 20px - 20px);
        max-height: calc(100vh - 70px - 20px); background: ${CONSTANTS.COLORS.BACKGROUND};
        border: 1px solid ${CONSTANTS.COLORS.BORDER}; border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 9999; display: flex;
        flex-direction: column; overflow: hidden;`

      const header = document.createElement('div')
      header.style.cssText = `
        padding: 8px; background: linear-gradient(to right, ${CONSTANTS.COLORS.HEADER_GRADIENT_START}, ${CONSTANTS.COLORS.HEADER_GRADIENT_END});
        border-bottom: 1px solid ${CONSTANTS.COLORS.BORDER}; cursor: move; display: flex;
        justify-content: space-between; align-items: center; user-select: none;
        height: ${CONSTANTS.POPUP.HEADER_HEIGHT}px; color: white;`

      const titleContainer = document.createElement('div')
      titleContainer.className = 'title-container'
      titleContainer.style.cssText = `display: flex; align-items: center; gap: 8px;`
      const title = document.createElement('span')
      title.textContent = 'CSV Collector'
      title.style.fontWeight = 'bold'
      titleContainer.appendChild(title)

      const controlsContainer = document.createElement('div')
      controlsContainer.style.cssText = `display: flex; align-items: center; gap: 8px;`

      const refreshIndicator = document.createElement('span')
      refreshIndicator.style.cssText = `font-size: 12px; color: #e0e0e0; cursor: pointer;`
      const refreshButton = document.createElement('button')
      refreshButton.innerHTML = '↻'
      refreshButton.title = 'Refresh now'
      refreshButton.style.cssText = `background: none; border: none; color: white; cursor: pointer; font-size: 16px;`
      const settingsBtn = document.createElement('button')
      settingsBtn.textContent = '⚙️'
      settingsBtn.title = 'Settings'
      settingsBtn.style.cssText = `background: none; border: none; color: white; cursor: pointer; font-size: 16px;`
      const toggleBtn = document.createElement('button')
      toggleBtn.textContent = '−'
      toggleBtn.title = 'Collapse'
      toggleBtn.style.cssText = `background: none; border: none; color: white; cursor: pointer; font-size: 18px;`

      controlsContainer.appendChild(refreshIndicator)
      controlsContainer.appendChild(refreshButton)
      controlsContainer.appendChild(settingsBtn)
      controlsContainer.appendChild(toggleBtn)
      header.appendChild(titleContainer)
      header.appendChild(controlsContainer)

      const contentWrapper = document.createElement('div')
      contentWrapper.style.cssText = `flex: 1; display: flex; flex-direction: column; min-height: 0; overflow: hidden;`
      const mainContent = document.createElement('div')
      mainContent.style.cssText = `flex: 1; padding: 10px; overflow: auto; min-height: 0;`
      const table = createTable()
      mainContent.appendChild(table)

      // Controls bar between table and log (checkbox + gripper for resize)
      const controlsBar = document.createElement('div')
      controlsBar.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 4px 10px;
        border-top: 1px solid ${CONSTANTS.COLORS.BORDER};
        border-bottom: 1px solid ${CONSTANTS.COLORS.BORDER};
        background: ${CONSTANTS.COLORS.HEADER_BACKGROUND};
        user-select: none;
        gap: 8px;
        flex-wrap: nowrap;
        min-height: 26px;
      `
      const autoScrollWrap = document.createElement('label')
      autoScrollWrap.style.cssText =
        'display:flex; align-items:center; gap:6px; cursor:pointer; white-space: nowrap;'
      const autoScrollCheckbox = document.createElement('input')
      autoScrollCheckbox.type = 'checkbox'
      autoScrollCheckbox.checked = true
      const autoScrollText = document.createElement('span')
      autoScrollText.textContent = 'Auto-scroll log'
      autoScrollText.style.cssText = 'white-space: nowrap;'
      autoScrollWrap.appendChild(autoScrollCheckbox)
      autoScrollWrap.appendChild(autoScrollText)

      const gripper = document.createElement('div')
      gripper.textContent = '⋮⋮'
      gripper.title = 'Drag to resize log height'
      gripper.style.cssText =
        'cursor: row-resize; padding: 0 6px; color:#666; height: 18px; display:flex; align-items:center;'

      controlsBar.appendChild(autoScrollWrap)
      controlsBar.appendChild(gripper)

      const logArea = document.createElement('textarea')
      logArea.style.cssText = `height: 80px; margin: 0 10px 10px 10px; padding: 5px; border: 1px solid ${CONSTANTS.COLORS.BORDER}; resize: none; flex-shrink: 0;`
      logArea.readOnly = true

      // Auto-scroll toggle
      autoScrollCheckbox.addEventListener('change', () => {
        state.autoScrollLog = !!autoScrollCheckbox.checked
      })

      // Drag to resize log height
      ;(function setupInnerResize() {
        let resizing = false
        let startY = 0
        let startHeight = 0
        const minLogHeight = 40
        function onDown(e) {
          if (e.target === autoScrollCheckbox || e.target === autoScrollText)
            return
          e.preventDefault()
          resizing = true
          startY = e.clientY
          startHeight = logArea.offsetHeight
          window.addEventListener('mousemove', onMove)
          window.addEventListener('mouseup', onUp)
        }
        function onMove(e) {
          if (!resizing) return
          const delta = startY - e.clientY // Drag up increases height
          const wrapperRect = contentWrapper.getBoundingClientRect()
          const maxLogHeight = Math.max(minLogHeight, wrapperRect.height - 100) // Reserve space for table
          const newHeight = Math.min(
            Math.max(minLogHeight, startHeight + delta),
            maxLogHeight
          )
          logArea.style.height = newHeight + 'px'
        }
        function onUp() {
          if (!resizing) return
          resizing = false
          window.removeEventListener('mousemove', onMove)
          window.removeEventListener('mouseup', onUp)
        }
        // Allow dragging from gripper or the whole bar
        gripper.addEventListener('mousedown', onDown)
        controlsBar.addEventListener('mousedown', (e) => {
          if (e.target === autoScrollCheckbox || e.target === autoScrollText)
            return
          onDown(e)
        })
      })()

      contentWrapper.appendChild(mainContent)
      contentWrapper.appendChild(controlsBar)
      contentWrapper.appendChild(logArea)

      const resizeHandle = document.createElement('div')
      resizeHandle.style.cssText = `position: absolute; right: 0; bottom: 0; width: 10px; height: 10px; cursor: se-resize;`

      const settingsPanel = createSettingsPanel()

      popup.appendChild(header)
      popup.appendChild(contentWrapper)
      popup.appendChild(resizeHandle)
      popup.appendChild(settingsPanel)

      // Store references on window
      window.csvCollectorTbody = table.querySelector('tbody')
      window.csvCollectorRefreshIndicator = refreshIndicator
      window.logToPopup = (message) => {
        const timestamp = new Date().toLocaleTimeString()
        logArea.value += `[${timestamp}] ${message}\n`
        if (state.autoScrollLog) {
          logArea.scrollTop = logArea.scrollHeight
        }
      }

      // Setup interactions
      setupDragAndDrop(popup, header)
      setupResize(popup, resizeHandle)
      setupToggle(popup, toggleBtn, contentWrapper)
      setupRefreshButton(refreshButton)
      setupRefreshIndicator(refreshIndicator, header, refreshButton)
      setupSettingsInteractions(settingsBtn, settingsPanel)

      state.originalHeight = popup.offsetHeight
      return popup
    }

    // ==================== INITIALIZATION ====================
    window.addEventListener('load', () => {
      try {
        const popup = createFloatingPopup()
        document.body.appendChild(popup)
        window.logToPopup('CSV Collector initialized.')

        refreshData()
        startRefreshInterval()
      } catch (error) {
        console.error('CSV Collector: Fatal error on initialization:', error)
      }
    })
  } catch (error) {
    console.error('CSV Collector: Fatal error in script:', error)
  }

  /**
   * Trích xuất dữ liệu từ một trang (document object).
   * @param {Document} doc - Document object của trang cần trích xuất dữ liệu.
   * @returns {object} - Một đối tượng chứa dữ liệu đã trích xuất.
   */
  function extractDataFromChildPage(doc, homeTeamNameCsv, awayTeamNameCsv) {
    // Log chi tiết khi bắt đầu trích xuất từ trang con
    console.log('CSV Collector: Starting extraction from child page.', {
      url: doc.URL,
      csvHome: homeTeamNameCsv,
      csvAway: awayTeamNameCsv,
    })

    // Helper function to get text content using XPath within the provided document.
    function getText(xpath, context) {
      try {
        // Use the passed 'doc' as the owner document for evaluation.
        const result = doc.evaluate(
          xpath,
          context,
          null,
          XPathResult.STRING_TYPE,
          null
        )
        // .stringValue will return the text content of the first matching node.
        return result.stringValue.trim()
      } catch (e) {
        console.error(`CSV Collector: Error evaluating XPath: ${xpath}`, e)
        return ''
      }
    }

    // Helper to extract just the number from strings like "10 Wins"
    const getNumber = (text) => (text.match(/\d+/) || [''])[0]

    const getSimilarityScore = (name1, name2) => {
      if (!name1 || !name2) return 0

      // 1. Normalization function
      const norm = (str) =>
        str
          .normalize('NFD') // Decompose combined characters (e.g., ö -> o + ¨)
          .replace(/[\u0300-\u036f]/g, '') // Remove diacritical marks
          .toLowerCase()

      // 2. Word extraction function (with improved noise filtering)
      const noiseWords = new Set([
        'fc',
        'cf',
        'sc',
        'fk',
        'ac',
        'sk',
        'spvgg',
        'tsv',
        'vfb',
        'sg',
        'von',
        'und',
        'and',
        'the',
        'for',
        'team',
        'bk',
        'club',
        'women',
      ])
      const getWords = (s) =>
        new Set(
          (norm(s).match(/\w+/g) || []).filter(
            (w) =>
              !noiseWords.has(w) &&
              !/^\d+$/.test(w) &&
              !/^(u\d{1,2}|ii|w|m)$/.test(w)
          )
        )

      const words1 = getWords(name1)
      const words2 = getWords(name2)

      if (words1.size === 0 && words2.size === 0) return 1.0 // Both are empty, perfect match
      if (words1.size === 0 || words2.size === 0) return 0 // One is empty, no match

      // 3. Jaccard Index Calculation
      const intersection = new Set([...words1].filter((x) => words2.has(x)))
      const union = new Set([...words1, ...words2])

      return union.size === 0 ? 1.0 : intersection.size / union.size
    }

    // Define the final data structure.
    const extractedData = {
      MP: {
        teamAName: '',
        teamBName: '',
        mpA: '',
        mpB: '',
      },
      H2H: {
        teamAName: '',
        teamBName: '',
        Matches: '',
        TeamAWin: '',
        Draw: '',
        TeamBWin: '',
        Last5TeamAWin: '',
        Last5TeamBWin: '',
        Last5Draw: '',
      },
      Neo: {
        TeamAName: '',
        TeamARun: {
          Overall: { Result: '', PPG: '' },
          Home: { Result: '', PPG: '' },
          Away: { Result: '', PPG: '' },
        },
        TeamATable: {
          XG: { Overall: '', Home: '', Away: '' },
          XGA: { Overall: '', Home: '', Away: '' },
        },
        TeamBName: '',
        TeamBRun: {
          Overall: { Result: '', PPG: '' },
          Home: { Result: '', PPG: '' },
          Away: { Result: '', PPG: '' },
        },
        TeamBTable: {
          XG: { Overall: '', Home: '', Away: '' },
          XGA: { Overall: '', Home: '', Away: '' },
        },
      },
    }

    // 1. Find the root element for H2H content.
    const rootResult = doc.evaluate(
      "//main[contains(@id, 'h2h_content')]",
      doc,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null
    )
    const rootNode = rootResult.singleNodeValue

    if (!rootNode) {
      const errorMsg =
        'DEBUG: H2H root container (`main#h2h_content`) not found.'
      // Log một phần HTML của body để dễ debug
      console.error(errorMsg, doc.body.innerHTML.substring(0, 500))
      if (window.logToPopup) window.logToPopup(errorMsg)
      // Trả về lỗi để hiển thị trên UI
      return { 'H2H Error': 'Root container not found' }
    }

    // --- H2H Section Processing ---
    ;(function processH2H() {
      const h2hResult = doc.evaluate(
        "./section[contains(@class, 'h2h')]",
        rootNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const h2hNode = h2hResult.singleNodeValue

      if (!h2hNode) {
        window.logToPopup('H2H section not found. Skipping H2H data.')
        extractedData.H2H.Error = 'H2H Section not found' // Ghi lỗi vào data
        return // Thoát khỏi hàm processH2H, nhưng không thoát khỏi hàm cha
      }

      const contentNodeResult = doc.evaluate(
        "./div[contains(@class, 'content')]/div[contains(@class, 'row')]",
        h2hNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const contentNode = contentNodeResult.singleNodeValue

      if (!contentNode) {
        window.logToPopup('H2H content not found. Skipping H2H data.')
        extractedData.H2H.Error = 'Content not found'
        return
      }

      let teamAName = getText(
        "normalize-space(./div[contains(@class, 'teamA')]/p[1]/a)",
        contentNode
      )
      if (!teamAName) {
        teamAName = getText(
          "./div[contains(@class, 'teamA')]/p[1]/text()[1]",
          contentNode
        )
      }

      let teamBName = getText(
        "normalize-space(./div[contains(@class, 'teamB')]/p[1]/a)",
        contentNode
      )
      if (!teamBName) {
        teamBName = getText(
          "./div[contains(@class, 'teamB')]/p[1]/text()[1]",
          contentNode
        )
      }

      const matchesText = getText(
        "./div[contains(@class, 'teamA')]/p[contains(@class, 'stat')]/span",
        contentNode
      )
      const teamAWinText = getText(
        "./div[contains(@class, 'teamA')]/div[contains(@class, 'row')]/p[contains(@class, 'fl') and contains(@class, 'w50')]",
        contentNode
      )
      const drawText = getText(
        "./div[contains(@class, 'teamA')]/div[contains(@class, 'row')]/p[contains(@class, 'draw-line') and contains(@class, 'w100')]",
        contentNode
      )
      const teamBWinText = getText(
        "./div[contains(@class, 'teamA')]/div[contains(@class, 'row')]/p[contains(@class, 'fr') and contains(@class, 'w50')]",
        contentNode
      )

      const normalize = (str) => (str ? str.toLowerCase().trim() : '')
      const h2hTeamA_norm = normalize(teamAName)
      const csvHome_norm = normalize(homeTeamNameCsv)

      let isSwapped = false
      if (h2hTeamA_norm && csvHome_norm && h2hTeamA_norm !== csvHome_norm) {
        const h2hTeamB_norm = normalize(teamBName)
        const csvAway_norm = normalize(awayTeamNameCsv)
        if (h2hTeamA_norm === csvAway_norm && h2hTeamB_norm === csvHome_norm) {
          isSwapped = true
          window.logToPopup(
            `H2H teams swapped for ${homeTeamNameCsv}. Correcting order.`
          )
        } else {
          window.logToPopup(
            `Warning: H2H/CSV name mismatch for ${homeTeamNameCsv}.`
          )
        }
      }

      extractedData.H2H.teamAName = isSwapped ? `[Swp] ${teamBName}` : teamAName
      extractedData.H2H.teamBName = isSwapped ? teamAName : teamBName
      extractedData.H2H.Matches = getNumber(matchesText)
      extractedData.H2H.TeamAWin = isSwapped
        ? getNumber(teamBWinText)
        : getNumber(teamAWinText)
      extractedData.H2H.Draw = getNumber(drawText)
      extractedData.H2H.TeamBWin = isSwapped
        ? getNumber(teamAWinText)
        : getNumber(teamBWinText)

      // --- Last 5 Matches Processing ---
      let last5TeamAWinCount = 0
      let last5TeamBWinCount = 0
      let last5DrawCount = 0

      const last5NodeResult = doc.evaluate(
        "./div[contains(@class, 'sliding-fixtures')]/div[contains(@class, 'inner')]",
        h2hNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const last5Node = last5NodeResult.singleNodeValue

      if (last5Node) {
        const last5Matches = doc.evaluate(
          './a',
          last5Node,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )

        const limit = Math.min(last5Matches.snapshotLength, 5)
        for (let i = 0; i < limit; i++) {
          const matchNode = last5Matches.snapshotItem(i)
          const winnerDivs = doc.evaluate(
            ".//div[contains(@class, 'winner')]",
            matchNode,
            null,
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
            null
          )

          if (winnerDivs.snapshotLength === 2) {
            last5DrawCount++
          } else if (winnerDivs.snapshotLength === 1) {
            const winnerName = winnerDivs.snapshotItem(0).textContent.trim()
            // Use fuzzy matching to determine the winner
            const scoreVsA = getSimilarityScore(winnerName, teamAName)
            const scoreVsB = getSimilarityScore(winnerName, teamBName)

            if (scoreVsA > scoreVsB) {
              last5TeamAWinCount++
            } else if (scoreVsB > scoreVsA) {
              last5TeamBWinCount++
            } else if (scoreVsA > 0) {
              // Handle ambiguous case where scores are equal but not zero
              window.logToPopup(`Ambiguous Last 5 winner: '${winnerName}'`)
            }
          }
        }
      }

      // Gán dữ liệu "Last 5" vào object, hoán đổi nếu cần
      extractedData.H2H.Last5TeamAWin = isSwapped
        ? last5TeamBWinCount
        : last5TeamAWinCount
      extractedData.H2H.Last5Draw = last5DrawCount
      extractedData.H2H.Last5TeamBWin = isSwapped
        ? last5TeamAWinCount
        : last5TeamBWinCount
    })() // Chạy hàm xử lý H2H ngay lập tức

    // 7. Placeholder for MP (Matches Played) section
    const mpNodeResult = doc.evaluate(
      "./section[contains(@data-parents, 'stats') and contains(@data-parents, 'tables')]",
      rootNode,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null
    )
    const mpNode = mpNodeResult.singleNodeValue

    if (mpNode) {
      // Team A data
      extractedData.MP.teamAName = getText(
        ".//div[contains(@class, 'row')]/div[1]/table[contains(@class, 'miniTableNeo')]/tbody/tr[contains(@class, 'selected')]/td[contains(@class,'leagueTableTeamName')]/a/div",
        mpNode
      )
      extractedData.MP.mpA = getText(
        ".//div[contains(@class, 'row')]/div[1]/table[contains(@class, 'miniTableNeo')]/tbody/tr[contains(@class, 'selected')]/td[preceding-sibling::*[1][self::td and contains(@class,'leagueTableTeamName')]]/p",
        mpNode
      )

      // Team B data (assuming it's in the second div)
      extractedData.MP.teamBName = getText(
        ".//div[contains(@class, 'row')]/div[2]/table[contains(@class, 'miniTableNeo')]/tbody/tr[contains(@class, 'selected')]/td[contains(@class,'leagueTableTeamName')]/a/div",
        mpNode
      )
      extractedData.MP.mpB = getText(
        ".//div[contains(@class, 'row')]/div[2]/table[contains(@class, 'miniTableNeo')]/tbody/tr[contains(@class, 'selected')]/td[preceding-sibling::*[1][self::td and contains(@class,'leagueTableTeamName')]]/p",
        mpNode
      )
    } else {
      console.log("CSV Collector: 'MP' section not found. Skipping.")
    }

    // Swap MP data if needed, similar to Neo and H2H logic
    if (extractedData.MP.teamAName && extractedData.MP.teamBName) {
      const scoreAH = getSimilarityScore(
        extractedData.MP.teamAName,
        homeTeamNameCsv
      )
      const scoreAA = getSimilarityScore(
        extractedData.MP.teamAName,
        awayTeamNameCsv
      )
      const scoreBH = getSimilarityScore(
        extractedData.MP.teamBName,
        homeTeamNameCsv
      )
      const scoreBA = getSimilarityScore(
        extractedData.MP.teamBName,
        awayTeamNameCsv
      )

      const scoreNoSwap = scoreAH + scoreBA
      const scoreSwap = scoreAA + scoreBH

      if (scoreSwap > scoreNoSwap) {
        window.logToPopup(
          `MP teams swapped for ${homeTeamNameCsv}. Correcting order.`
        )
        const tempName = extractedData.MP.teamAName
        extractedData.MP.teamAName = `[Swp] ${extractedData.MP.teamBName}`
        extractedData.MP.teamBName = tempName
        ;[extractedData.MP.mpA, extractedData.MP.mpB] = [
          extractedData.MP.mpB,
          extractedData.MP.mpA,
        ]
      }
    }

    // 8. Placeholder for "Neo" section
    const neoRootNodeResult = doc.evaluate(
      "./section[contains(@data-parents, 'stats')]/div[contains(@class, 'stat') and ./div[contains(@class, 'neo-team-overview')]]",
      rootNode,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null
    )
    const neoRootNode = neoRootNodeResult.singleNodeValue

    if (neoRootNode) {
      window.logToPopup('Neo section found, extracting data...')
      // Giả sử tên đội trong phần Neo có thể khác, cần lấy lại và so sánh
      // Lấy tên đội từ phần Neo. Lưu ý: XPath index bắt đầu từ 1.
      const neoTeamAName = getText(
        "./div[contains(@class, 'neo-team-overview')][1]/div[contains(@class,'nav-bg')]/div/h3/a",
        neoRootNode
      )
      const neoTeamBName = getText(
        "./div[contains(@class, 'neo-team-overview')][2]/div[contains(@class,'nav-bg')]/div/h3/a",
        neoRootNode
      )
      extractedData.Neo.TeamAName = neoTeamAName
      extractedData.Neo.TeamBName = neoTeamBName

      // --- Team A Run ---
      // TODO: Bổ sung XPath để tìm node cha cho phần "Team A Run" bên trong neoRootNode
      const teamARunNodeResult = doc.evaluate(
        "./div[contains(@class, 'neo-team-overview')][1]/div[./div/div/ul[contains(@class,'form-run')]]",
        neoRootNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const teamARunNode = teamARunNodeResult.singleNodeValue

      if (teamARunNode) {
        // Trích xuất Overall Result: lấy text từ tất cả các thẻ <li> và nối lại.
        const overallResultNodes = doc.evaluate(
          "./div[2]/div/ul[contains(@class,'form-run')]/li",
          teamARunNode,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )
        const resultTexts = []
        for (let i = 0; i < overallResultNodes.snapshotLength; i++) {
          resultTexts.push(
            overallResultNodes.snapshotItem(i).textContent.trim()
          )
        }
        extractedData.Neo.TeamARun.Overall.Result = resultTexts.join('')

        // Trích xuất Overall PPG
        extractedData.Neo.TeamARun.Overall.PPG = getText(
          "./div[2]/div/div[contains(@class, 'form-box')]",
          teamARunNode
        )

        // Trích xuất Home Result và PPG
        const homeResultNodes = doc.evaluate(
          "./div[3]/div/ul[contains(@class,'form-run')]/li",
          teamARunNode,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )
        const homeResultTexts = []
        for (let i = 0; i < homeResultNodes.snapshotLength; i++) {
          homeResultTexts.push(
            homeResultNodes.snapshotItem(i).textContent.trim()
          )
        }
        extractedData.Neo.TeamARun.Home.Result = homeResultTexts.join('')
        extractedData.Neo.TeamARun.Home.PPG = getText(
          "./div[3]/div/div[contains(@class, 'form-box')]",
          teamARunNode
        )

        // Trích xuất Away Result và PPG
        const awayResultNodes = doc.evaluate(
          "./div[4]/div/ul[contains(@class,'form-run')]/li",
          teamARunNode,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )
        const awayResultTexts = []
        for (let i = 0; i < awayResultNodes.snapshotLength; i++) {
          awayResultTexts.push(
            awayResultNodes.snapshotItem(i).textContent.trim()
          )
        }
        extractedData.Neo.TeamARun.Away.Result = awayResultTexts.join('')
        extractedData.Neo.TeamARun.Away.PPG = getText(
          "./div[4]/div/div[contains(@class, 'form-box')]",
          teamARunNode
        )
      } else {
        console.log("CSV Collector: 'Team A Run' node not found. Skipping.")
      }

      // --- Team A Table ---
      const teamATableNodeResult = doc.evaluate(
        "./div[contains(@class, 'neo-team-overview')][1]/div[./div[contains(@class, 'second-table')]]",
        neoRootNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const teamATableNode = teamATableNodeResult.singleNodeValue

      if (teamATableNode) {
        // Find xG node and extract its data
        const xGNodeResult = doc.evaluate(
          "./div[./div[text() = 'xG']]",
          teamATableNode,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        )
        const xGNode = xGNodeResult.singleNodeValue
        if (xGNode) {
          extractedData.Neo.TeamATable.XG.Overall = getText('./div[2]', xGNode)
          extractedData.Neo.TeamATable.XG.Home = getText('./div[3]', xGNode)
          extractedData.Neo.TeamATable.XG.Away = getText('./div[4]', xGNode)
        } else {
          console.log("CSV Collector: 'xG' node not found. Skipping.")
        }

        // Find xGA node and extract its data
        const xGANodeResult = doc.evaluate(
          "./div[./div[text() = 'xGA']]",
          teamATableNode,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        )
        const xGANode = xGANodeResult.singleNodeValue
        if (xGANode) {
          extractedData.Neo.TeamATable.XGA.Overall = getText(
            './div[2]',
            xGANode
          )
          extractedData.Neo.TeamATable.XGA.Home = getText('./div[3]', xGANode)
          extractedData.Neo.TeamATable.XGA.Away = getText('./div[4]', xGANode)
        } else {
          console.log("CSV Collector: 'xGA' node not found. Skipping.")
        }
      } else {
        console.log("CSV Collector: 'Team A Table' node not found. Skipping.")
      }

      // --- Team B Run ---
      const teamBRunNodeResult = doc.evaluate(
        "./div[contains(@class, 'neo-team-overview')][2]/div[./div/div/ul[contains(@class,'form-run')]]",
        neoRootNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const teamBRunNode = teamBRunNodeResult.singleNodeValue

      if (teamBRunNode) {
        // Overall
        const bOverallResultNodes = doc.evaluate(
          "./div[2]/div/ul[contains(@class,'form-run')]/li",
          teamBRunNode,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )
        const bOverallResultTexts = []
        for (let i = 0; i < bOverallResultNodes.snapshotLength; i++) {
          bOverallResultTexts.push(
            bOverallResultNodes.snapshotItem(i).textContent.trim()
          )
        }
        extractedData.Neo.TeamBRun.Overall.Result = bOverallResultTexts.join('')
        extractedData.Neo.TeamBRun.Overall.PPG = getText(
          "./div[2]/div/div[contains(@class, 'form-box')]",
          teamBRunNode
        )

        // Home
        const bHomeResultNodes = doc.evaluate(
          "./div[3]/div/ul[contains(@class,'form-run')]/li",
          teamBRunNode,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )
        const bHomeResultTexts = []
        for (let i = 0; i < bHomeResultNodes.snapshotLength; i++) {
          bHomeResultTexts.push(
            bHomeResultNodes.snapshotItem(i).textContent.trim()
          )
        }
        extractedData.Neo.TeamBRun.Home.Result = bHomeResultTexts.join('')
        extractedData.Neo.TeamBRun.Home.PPG = getText(
          "./div[3]/div/div[contains(@class, 'form-box')]",
          teamBRunNode
        )

        // Away
        const bAwayResultNodes = doc.evaluate(
          "./div[4]/div/ul[contains(@class,'form-run')]/li",
          teamBRunNode,
          null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        )
        const bAwayResultTexts = []
        for (let i = 0; i < bAwayResultNodes.snapshotLength; i++) {
          bAwayResultTexts.push(
            bAwayResultNodes.snapshotItem(i).textContent.trim()
          )
        }
        extractedData.Neo.TeamBRun.Away.Result = bAwayResultTexts.join('')
        extractedData.Neo.TeamBRun.Away.PPG = getText(
          "./div[4]/div/div[contains(@class, 'form-box')]",
          teamBRunNode
        )
      } else {
        console.log("CSV Collector: 'Team B Run' node not found. Skipping.")
      }

      // --- Team B Table ---
      const teamBTableNodeResult = doc.evaluate(
        "./div[contains(@class, 'neo-team-overview')][2]/div[./div[contains(@class, 'second-table')]]",
        neoRootNode,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      )
      const teamBTableNode = teamBTableNodeResult.singleNodeValue

      if (teamBTableNode) {
        const bXGNode = doc.evaluate(
          "./div[./div[text() = 'xG']]",
          teamBTableNode,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        ).singleNodeValue
        if (bXGNode) {
          extractedData.Neo.TeamBTable.XG.Overall = getText('./div[2]', bXGNode)
          extractedData.Neo.TeamBTable.XG.Home = getText('./div[3]', bXGNode)
          extractedData.Neo.TeamBTable.XG.Away = getText('./div[4]', bXGNode)
        }
        const bXGANode = doc.evaluate(
          "./div[./div[text() = 'xGA']]",
          teamBTableNode,
          null,
          XPathResult.FIRST_ORDERED_NODE_TYPE,
          null
        ).singleNodeValue
        if (bXGANode) {
          extractedData.Neo.TeamBTable.XGA.Overall = getText(
            './div[2]',
            bXGANode
          )
          extractedData.Neo.TeamBTable.XGA.Home = getText('./div[3]', bXGANode)
          extractedData.Neo.TeamBTable.XGA.Away = getText('./div[4]', bXGANode)
        }
      } else {
        console.log("CSV Collector: 'Team B Table' node not found. Skipping.")
      }

      // 9. Final check and swap for Neo data if needed.
      // This logic runs *after* all data has been extracted as-is.
      // Calculate the 4 scores using Jaccard index
      const scoreAH = getSimilarityScore(neoTeamAName, homeTeamNameCsv)
      const scoreAA = getSimilarityScore(neoTeamAName, awayTeamNameCsv)
      const scoreBH = getSimilarityScore(neoTeamBName, homeTeamNameCsv)
      const scoreBA = getSimilarityScore(neoTeamBName, awayTeamNameCsv)

      // Log the scores for debugging
      window.logToPopup(
        `Scores for ${homeTeamNameCsv}: A/H=${scoreAH.toFixed(
          2
        )}, A/A=${scoreAA.toFixed(2)}, B/H=${scoreBH.toFixed(
          2
        )}, B/A=${scoreBA.toFixed(2)}`
      )

      // New swap logic: swap if the "swapped" pairing has a higher total score
      const scoreNoSwap = scoreAH + scoreBA // (A vs Home) + (B vs Away)
      const scoreSwap = scoreAA + scoreBH // (A vs Away) + (B vs Home)

      if (scoreSwap > scoreNoSwap) {
        window.logToPopup(
          `Neo teams swapped for ${homeTeamNameCsv}. Correcting order.`
        )

        // Perform the swap using array destructuring for conciseness
        ;[extractedData.Neo.TeamAName, extractedData.Neo.TeamBName] = [
          `[Swp] ${extractedData.Neo.TeamBName}`,
          extractedData.Neo.TeamAName,
        ]
        ;[extractedData.Neo.TeamARun, extractedData.Neo.TeamBRun] = [
          extractedData.Neo.TeamBRun,
          extractedData.Neo.TeamARun,
        ]
        ;[extractedData.Neo.TeamATable, extractedData.Neo.TeamBTable] = [
          extractedData.Neo.TeamBTable,
          extractedData.Neo.TeamATable,
        ]
      }
    } else {
      // Log nếu không tìm thấy phần Neo để dễ debug
      console.log("CSV Collector: 'Neo' section root node not found. Skipping.")
    }

    // Log đối tượng dữ liệu cuối cùng trước khi trả về
    console.log(
      'CSV Collector: Finished extraction from child page. Result:',
      JSON.stringify(extractedData, null, 2)
    )
    // Log một bản tóm tắt ngắn gọn lên UI
    if (window.logToPopup)
      window.logToPopup(
        `Extracted H2H: ${extractedData.H2H.teamAName} ${extractedData.H2H.TeamAWin} - ${extractedData.H2H.Draw} - ${extractedData.H2H.TeamBWin} ${extractedData.H2H.teamBName}`
      )

    return extractedData
  }
})()
